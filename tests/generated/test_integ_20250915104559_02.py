import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest as _pytest
_pytest.skip('generator: banned private imports detected; skipping module', allow_module_level=True)

try:
    import pytest
    from types import SimpleNamespace
    import builtins
    # authentication
    from conduit.apps.authentication.models import User
    from conduit.apps.authentication.backends import JWTAuthentication, jwt as backend_jwt, User as BackendUser
    # articles signals
    from conduit.apps.articles.signals import add_slug_to_article_if_not_exists
    # core utils for monkeypatching random string generator
    from conduit.apps.core import utils as core_utils
    # profiles serializers
    from conduit.apps.profiles.serializers import get_following
    # exceptions
    from rest_framework.exceptions import AuthenticationFailed
except ImportError as e:
    import pytest as _pytest
    _pytest.skip("Required app modules not available: {}".format(e), allow_module_level=True)


@pytest.mark.parametrize("first_name,last_name,expected_full", [
    ("Alice", "Smith", "Alice Smith"),
    ("", "Doe", " Doe"),
    (None, None, "None None"),
])
def test_user_token_and_get_full_name(monkeypatch, first_name, last_name, expected_full):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create a User instance with given names and monkeypatch token generation
    # Act: call token() and get_full_name()
    # Assert: token returns mocked value and full name matches expectations
    user = User()
    # set attributes that get_full_name likely uses
    setattr(user, "first_name", first_name)
    setattr(user, "last_name", last_name)

    # Ensure _generate_jwt_token exists and is deterministic for the test
    monkeypatch.setattr(user, "_generate_jwt_token", lambda: "fixed-jwt-token", raising=False)

    # Act
    token_value = getattr(user, "token")() if callable(getattr(user, "token")) else getattr(user, "token")
    full_name = getattr(user, "get_full_name")()

    # Assert
    assert isinstance(token_value, str)
    assert token_value == "fixed-jwt-token"
    assert full_name == expected_full


@pytest.mark.parametrize("jwt_behavior, expect_success", [
    ("valid_payload", True),
    ("decode_error", False),
    ("no_user", False),
])
def test_jwtauthentication_authenticate_and_authenticate_credentials(monkeypatch, jwt_behavior, expect_success):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: prepare a fake token and a backend instance
    backend = JWTAuthentication()

    fake_token = "Bearer sometoken"
    raw_token = "sometoken"

    # Prepare fake request object with header access patterns used by DRF
    class FakeRequest:
        def __init__(self, token):
            # DRF may check .META or .headers; support common patterns
            self.META = {"HTTP_AUTHORIZATION": token}
            self.headers = {"Authorization": token}

    request = FakeRequest(fake_token)

    # Create a fake user object to be returned by the backend user lookup
    fake_user = SimpleNamespace(username="tester", id=1)

    # Helper to simulate BackendUser.objects.get
    class FakeManager:
        def __init__(self, should_return):
            self._should_return = should_return

        def get(self, **kwargs):
            if self._should_return:
                return fake_user
            # Simulate Django's DoesNotExist by raising attribute from class
            raise BackendUser.DoesNotExist()

    # Monkeypatch jwt.decode behavior depending on scenario
    if jwt_behavior == "valid_payload":
        monkeypatch.setattr(backend_jwt, "decode", lambda token, key, algorithms: {"user_id": 1})
        # Ensure BackendUser.objects.get will return a user
        monkeypatch.setattr(BackendUser, "objects", FakeManager(should_return=True), raising=False)
    elif jwt_behavior == "decode_error":
        def raise_decode(*a, **k):
            raise Exception("Invalid token")
        monkeypatch.setattr(backend_jwt, "decode", raise_decode)
        # In this case, user lookup shouldn't be reached, but provide a manager anyway
        monkeypatch.setattr(BackendUser, "objects", FakeManager(should_return=True), raising=False)
    else:  # no_user
        monkeypatch.setattr(backend_jwt, "decode", lambda token, key, algorithms: {"user_id": 9999})
        monkeypatch.setattr(BackendUser, "objects", FakeManager(should_return=False), raising=False)

    # Act / Assert
    if expect_success:
        # Should return a tuple (user, token)
        result = backend.authenticate(request)
        assert isinstance(result, tuple)
        returned_user, returned_token = result
        assert returned_user is fake_user
        assert returned_token == raw_token
    else:
        with pytest.raises(AuthenticationFailed):
            # When authentication fails, either in decode or missing user, expect AuthenticationFailed
            backend.authenticate(request)


@pytest.mark.parametrize("initial_slug, created_flag, expected_saved", [
    (None, True, True),       # new article and no slug -> should be saved with slug
    ("existing-slug", True, False),  # slug exists -> should not be changed or saved
    (None, False, False),     # not created (updated) -> should not set slug
])
def test_add_slug_to_article_if_not_exists_behaviour(monkeypatch, initial_slug, created_flag, expected_saved):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create a fake Article instance
    saved = {"called": False}

    class FakeArticle:
        def __init__(self, title, slug):
            self.title = title
            self.slug = slug

        def save(self):
            saved["called"] = True

    article = FakeArticle(title="Test Title For Slug", slug=initial_slug)

    # Monkeypatch generate_random_string to deterministic value to make slug predictable
    monkeypatch.setattr(core_utils, "generate_random_string", lambda length=6: "-rnd", raising=False)

    # Act: call signal handler as Django would
    add_slug_to_article_if_not_exists(sender=type(article), instance=article, created=created_flag)

    # Assert: saved state and slug presence/absence consistent with expectations
    assert saved["called"] is expected_saved
    if created_flag and initial_slug is None:
        # slug should be set to slugified title plus random string; minimal check: contains slugified words
        assert article.slug is not None
        assert "test-title-for-slug" in article.slug or "test_title_for_slug" in article.slug
    if initial_slug is not None:
        assert article.slug == initial_slug


@pytest.mark.parametrize("viewer_is_none, profile_reports_following, expected", [
    (False, True, True),
    (False, False, False),
    (True, True, False),  # no viewer means cannot be following
])
def test_get_following_serializer_field_interaction(monkeypatch, viewer_is_none, profile_reports_following, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create a dummy serializer self object with context and a dummy obj with user profile
    viewer = None if viewer_is_none else SimpleNamespace(username="viewer")
    request = SimpleNamespace(user=viewer)
    dummy_self = SimpleNamespace(context={"request": request})

    # The profile user object; provide method(s) that get_following might call
    profile_user = SimpleNamespace(username="author")

    # Provide both possible method names to maximize compatibility with implementation
    def is_followed_by(other):
        return profile_reports_following

    def is_following(other):
        return profile_reports_following

    setattr(profile_user, "is_followed_by", is_followed_by)
    setattr(profile_user, "is_following", is_following)

    obj = SimpleNamespace(user=profile_user)

    # Act
    result = get_following(dummy_self, obj)

    # Assert
    assert isinstance(result, bool)
    assert result is expected
