import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest

try:
    from conduit.apps.authentication.models import get_short_name, _generate_jwt_token
    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.authentication.serializers import RegistrationSerializer
    from conduit.apps.authentication.signals import create_related_profile
    from conduit.apps.core.exceptions import core_exception_handler, _handle_generic_error, _handle_not_found_error
    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.profiles.models import follow, unfollow, is_following
    from rest_framework import exceptions as drf_exceptions
    from rest_framework.response import Response
    import string
except ImportError as e:
    pytest.skip(f"Skipping tests due to import error: {e}", allow_module_level=True)


from unittest import mock


def test_get_short_name_returns_expected_string():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyUser:
        def __init__(self, username):
            self.username = username

    user = DummyUser(username="alice")

    # Act
    result = get_short_name(user)

    # Assert
    assert isinstance(result, str)
    assert result == "alice"


def test__generate_jwt_token_returns_jwt_like_string():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyUser:
        def __init__(self, pk):
            self.pk = pk
            self.id = pk

    user = DummyUser(pk=1)

    # Act
    token = _generate_jwt_token(user)

    # Assert
    assert isinstance(token, str)
    # Basic structure check for JWT (header.payload.signature)
    assert token.count(".") == 2


def test_userjsonrenderer_render_emits_bytes_and_contains_user_key():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()
    payload = {"user": {"email": "me@example.com", "username": "me"}}
    # Act
    rendered = renderer.render(payload, accepted_media_type="application/json", renderer_context={})
    # Assert
    assert isinstance(rendered, (bytes, bytearray))
    assert b'"user"' in rendered


@pytest.mark.parametrize(
    "input_data, should_raise",
    [
        ({"password": "abc", "password2": "abc"}, False),
        ({"password": "abc", "password2": "def"}, True),
        ({}, True),  # missing expected keys should raise
    ],
)
def test_registration_serializer_validate_password_matching_and_mismatch(input_data, should_raise):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    serializer = RegistrationSerializer()

    # Act / Assert
    if should_raise:
        with pytest.raises(Exception):
            # Serializer.validate usually raises serializers.ValidationError for invalid data
            serializer.validate(input_data)
    else:
        result = serializer.validate(input_data)
        assert isinstance(result, dict)
        # When valid, should echo through at least the provided keys
        assert "password" in result and "password2" in result


def test_create_related_profile_calls_profile_create_when_created_true(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    created_calls = {}

    class DummyProfileManager:
        def create(self, **kwargs):
            created_calls["called"] = True
            created_calls["kwargs"] = kwargs
            return "created_profile"

    class DummyProfileModel:
        objects = DummyProfileManager()

    # Patch the Profile model used inside the signal handler to our dummy
    monkeypatch.setattr("conduit.apps.authentication.signals.Profile", DummyProfileModel, raising=False)

    class DummyUser:
        def __init__(self, username):
            self.username = username

    user = DummyUser(username="bob")

    # Act
    # create_related_profile signature expected like (sender, instance, created, **kwargs)
    create_related_profile(sender=DummyUser, instance=user, created=True)

    # Assert
    assert created_calls.get("called", False) is True
    # Expect that create got the user reference
    assert created_calls["kwargs"].get("user") is user


def test_create_related_profile_does_not_create_when_created_false(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    created_calls = {"called": False}

    class DummyProfileManager:
        def create(self, **kwargs):
            created_calls["called"] = True
            return "created_profile"

    class DummyProfileModel:
        objects = DummyProfileManager()

    monkeypatch.setattr("conduit.apps.authentication.signals.Profile", DummyProfileModel, raising=False)

    class DummyUser:
        pass

    user = DummyUser()

    # Act
    create_related_profile(sender=DummyUser, instance=user, created=False)

    # Assert
    assert created_calls["called"] is False


def test__handle_not_found_error_returns_response_with_404_and_dict_body():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    exc = drf_exceptions.NotFound(detail="nope")

    # Act
    response = _handle_not_found_error(exc)

    # Assert
    assert isinstance(response, Response)
    assert getattr(response, "status_code", None) == getattr(exc, "status_code", 404)
    assert isinstance(response.data, dict)


def test__handle_generic_error_returns_response_with_500_and_dict_body():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    exc = Exception("boom")

    # Act
    response = _handle_generic_error(exc)

    # Assert
    assert isinstance(response, Response)
    # Some handlers may set 500 explicitly; ensure an int status code is present and >=500
    assert isinstance(response.status_code, int)
    assert response.status_code >= 500
    assert isinstance(response.data, dict)


def test_core_exception_handler_delegates_to_specific_handlers():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange - not found
    nf_exc = drf_exceptions.NotFound(detail="not found")

    # Act
    nf_response = core_exception_handler(nf_exc, context={})

    # Assert
    assert isinstance(nf_response, Response)
    assert nf_response.status_code == nf_exc.status_code

    # Arrange - generic exception (not a DRF APIException)
    gen_exc = Exception("generic fail")

    # Act
    gen_response = core_exception_handler(gen_exc, context={})

    # Assert
    assert isinstance(gen_response, Response)
    assert gen_response.status_code >= 500


def test_generate_random_string_length_and_charset_and_edge_cases():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act
    s = generate_random_string(12)

    # Assert
    assert isinstance(s, str)
    assert len(s) == 12
    allowed = set(string.ascii_letters + string.digits)
    assert all(ch in allowed for ch in s)

    # Edge case: zero length
    zero = generate_random_string(0)
    assert isinstance(zero, str)
    assert zero == ""


class SimpleRelSet:
    def __init__(self):
        self._s = set()

    def add(self, v):
        self._s.add(v)

    def remove(self, v):
        self._s.discard(v)

    def all(self):
        # emulate Django QuerySet .all()
        return list(self._s)

    def __contains__(self, item):
        return item in self._s


class DummyProfileObj:
    def __init__(self, name):
        self.name = name
        self.followers = SimpleRelSet()
        self.following = SimpleRelSet()

    def __repr__(self):
        return f"DummyProfile({self.name})"


@pytest.mark.parametrize("initially_following", [False, True])
def test_follow_unfollow_and_is_following_behaviour(initially_following):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    alice = DummyProfileObj("alice")
    bob = DummyProfileObj("bob")

    if initially_following:
        # make alice follow bob before tests
        alice.following.add(bob)
        bob.followers.add(alice)

    # Act - ensure follow idempotent
    follow(alice, bob)

    # Assert - after follow, either side should reflect following relationship
    followed_via_following = bob in alice.following
    followed_via_followers = alice in bob.followers
    assert followed_via_following or followed_via_followers
    assert is_following(alice, bob) is True

    # Act - unfollow
    unfollow(alice, bob)

    # Assert - after unfollow, relationship should be removed (both checks allow for either implementation)
    still_following_via_following = bob in alice.following
    still_following_via_followers = alice in bob.followers
    assert not (still_following_via_following or still_following_via_followers)
    assert is_following(alice, bob) is False


def test_unfollow_nonexistent_relationship_is_noop():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    charlie = DummyProfileObj("charlie")
    dave = DummyProfileObj("dave")

    # ensure they are not following initially
    assert not is_following(charlie, dave)

    # Act - should not raise
    unfollow(charlie, dave)

    # Assert - still not following
    assert not is_following(charlie, dave)
