import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import json
    from types import SimpleNamespace
    from unittest.mock import Mock
    from conduit.apps.articles.renderers import ArticleJSONRenderer, CommentJSONRenderer
    from conduit.apps.articles.views import TagListAPIView
    from conduit.apps.articles.models import Tag
except ImportError:
    import pytest
    pytest.skip("Required project modules or third-party packages are not available", allow_module_level=True)


def test_article_json_renderer_renders_article_and_types():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()
    article = {
        "slug": "test-slug",
        "title": "Test Title",
        "description": "A short desc",
        "body": "The body of the article",
        "tagList": ["python", "testing"],
        "createdAt": "2020-01-01T00:00:00Z",
        "updatedAt": "2020-01-02T00:00:00Z",
        "favorited": False,
        "favoritesCount": 0,
        "author": {
            "username": "jdoe",
            "bio": "dev",
            "image": None,
            "following": False
        }
    }

    # Act
    rendered = renderer.render({"article": article})
    # Some renderers return bytes, others strings; normalize to string for json.loads
    rendered_str = rendered.decode() if isinstance(rendered, (bytes, bytearray)) else rendered
    parsed = json.loads(rendered_str)

    # Assert
    assert isinstance(parsed, dict)
    assert "article" in parsed
    out = parsed["article"]
    assert out["slug"] == "test-slug"
    assert out["title"] == "Test Title"
    assert isinstance(out["tagList"], list)
    assert out["tagList"] == ["python", "testing"]
    assert isinstance(out["author"], dict)
    assert out["author"]["username"] == "jdoe"
    assert isinstance(out["favoritesCount"], int)


def test_comment_json_renderer_renders_comment_and_types():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = CommentJSONRenderer()
    comment = {
        "id": 123,
        "createdAt": "2020-01-03T00:00:00Z",
        "updatedAt": "2020-01-04T00:00:00Z",
        "body": "A comment body",
        "author": {
            "username": "commenter",
            "bio": None,
            "image": None,
            "following": False
        }
    }

    # Act
    rendered = renderer.render({"comment": comment})
    rendered_str = rendered.decode() if isinstance(rendered, (bytes, bytearray)) else rendered
    parsed = json.loads(rendered_str)

    # Assert
    assert isinstance(parsed, dict)
    assert "comment" in parsed
    out = parsed["comment"]
    assert out["id"] == 123
    assert out["body"] == "A comment body"
    assert isinstance(out["author"], dict)
    assert out["author"]["username"] == "commenter"


@pytest.mark.parametrize(
    "values_list_result, expected_set",
    [
        (["python", "django", "python"], {"python", "django"}),  # normal duplicate case
        ([], set()),  # edge: no tags
    ],
)
def test_taglist_view_returns_unique_tags(monkeypatch, values_list_result, expected_set):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Monkeypatch Tag.objects.values_list to return controlled lists
    monkeypatch.setattr(Tag, "objects", SimpleNamespace(values_list=lambda *a, **k: values_list_result))
    view = TagListAPIView()
    fake_request = Mock()

    # Act
    response = view.get(fake_request)

    # The view may return a DRF Response or a plain dict; normalize to dict-like access
    if hasattr(response, "data"):
        tags = response.data.get("tags")
    else:
        tags = response.get("tags") if isinstance(response, dict) else None

    # Assert
    assert isinstance(tags, list)
    assert set(tags) == expected_set


def test_taglist_view_propagates_errors(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    def raise_error(*a, **k):
        raise RuntimeError("database unavailable")

    monkeypatch.setattr(Tag, "objects", SimpleNamespace(values_list=raise_error))
    view = TagListAPIView()
    fake_request = Mock()

    # Act / Assert: ensure underlying errors propagate for callers to handle
    with pytest.raises(RuntimeError):
        view.get(fake_request)
