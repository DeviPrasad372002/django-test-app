import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import json
    import random
    import string

    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.authentication.models import User
    from conduit.apps.articles.renderers import CommentJSONRenderer
except ImportError as e:
    import pytest
    pytest.skip(f"skipping tests: {e}", allow_module_level=True)


def test_generate_random_string_various_lengths_and_type(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: make random.choice deterministic to always return 'x'
    monkeypatch.setattr(random, "choice", lambda seq: "x")

    # Act: generate strings of various lengths
    result_len_5 = generate_random_string(5)
    result_len_0 = generate_random_string(0)

    # Assert: results are strings of expected length and content
    assert isinstance(result_len_5, str)
    assert result_len_5 == "x" * 5
    assert isinstance(result_len_0, str)
    assert result_len_0 == ""


@pytest.mark.parametrize(
    "bad_input",
    [
        ("not_an_int",),  # non-integer should raise TypeError when used in range()
    ],
)
def test_generate_random_string_error_path(bad_input):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act / Assert: passing a non-integer should raise a TypeError
    with pytest.raises(TypeError):
        generate_random_string(bad_input)  # type: ignore[arg-type]


def test_user_get_full_name_and_token_property_monkeypatched(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create a User instance without touching the DB
    user = User(first_name="Alice", last_name="Wonderland")

    # Act: call get_full_name
    full_name = user.get_full_name()

    # Assert: full_name combines first and last name appropriately and is a string
    assert isinstance(full_name, str)
    assert full_name == "Alice Wonderland"

    # Arrange: monkeypatch the internal token generator to a deterministic value
    monkeypatch.setattr(User, "_generate_jwt_token", lambda self: "FIXED_TOKEN")

    # Act: access the token property
    token_value = user.token

    # Assert: token_property returns the patched deterministic token
    assert isinstance(token_value, str)
    assert token_value == "FIXED_TOKEN"

    # Arrange: monkeypatch the internal token generator to raise an error
    def _raise_error(self):
        raise ValueError("generator failure")

    monkeypatch.setattr(User, "_generate_jwt_token", _raise_error)

    # Act / Assert: accessing token should propagate the ValueError
    with pytest.raises(ValueError):
        _ = user.token


def test_comment_json_renderer_renders_and_errors():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: instantiate the renderer
    renderer = CommentJSONRenderer()

    # Act: render a simple comment dict
    payload = {"comment": {"body": "Hello", "author": "bob"}}
    rendered = renderer.render(payload, renderer_context={})

    # Assert: result is bytes and decodes back to equivalent JSON structure
    assert isinstance(rendered, (bytes, bytearray))
    decoded = json.loads(rendered.decode("utf-8"))
    assert isinstance(decoded, dict)
    assert decoded == payload

    # Error path: attempting to render a non-serializable structure (set) should raise TypeError
    with pytest.raises(TypeError):
        renderer.render({"comment": {"body": set([1, 2, 3])}}, renderer_context={})
