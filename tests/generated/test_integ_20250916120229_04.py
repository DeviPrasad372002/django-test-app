import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import importlib
    import string
    from types import SimpleNamespace

    relations_mod = importlib.import_module("conduit.apps.articles.relations")
    TagRelatedField = getattr(relations_mod, "TagRelatedField")
    utils_mod = importlib.import_module("conduit.apps.core.utils")
    generate_random_string = getattr(utils_mod, "generate_random_string")
    profiles_serializers_mod = importlib.import_module("conduit.apps.profiles.serializers")
    get_following = getattr(profiles_serializers_mod, "get_following")
except ImportError:
    import pytest
    pytest.skip("Required project modules not available for integration tests", allow_module_level=True)


def test_tagrelatedfield_to_internal_and_representation_success(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    field = TagRelatedField()
    # define fake Tag with objects.get_or_create
    class FakeTag:
        def __init__(self, name):
            self.name = name

        class objects:
            @staticmethod
            def get_or_create(name):
                return (FakeTag(name), True)

    # Act: replace Tag in the relations module with our fake
    monkeypatch.setattr(relations_mod, "Tag", FakeTag, raising=True)

    # Act: convert string to tag object
    result_obj = field.to_internal_value("python-testing")

    # Assert
    assert isinstance(result_obj, FakeTag)
    assert result_obj.name == "python-testing"

    # Act: represent tag object as string
    rep = field.to_representation(result_obj)

    # Assert representation is the tag name (string)
    assert isinstance(rep, str)
    assert rep == "python-testing"


def test_tagrelatedfield_to_internal_value_propagates_errors(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    field = TagRelatedField()

    class BrokenTagObjects:
        @staticmethod
        def get_or_create(name):
            raise ValueError("creation failed")

    class BrokenTag:
        objects = BrokenTagObjects

    monkeypatch.setattr(relations_mod, "Tag", BrokenTag, raising=True)

    # Act / Assert: ensure the original error propagates
    with pytest.raises(ValueError):
        field.to_internal_value("will-fail")


@pytest.mark.parametrize(
    "length, expect_exception",
    [
        (0, False),
        (1, False),
        (8, False),
        (16, False),
        (-1, True),
    ],
)
def test_generate_random_string_various_lengths(length, expect_exception):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act / Assert
    if expect_exception:
        with pytest.raises(Exception):
            generate_random_string(length)
        return

    s = generate_random_string(length)

    # Assert type and length
    assert isinstance(s, str)
    assert len(s) == length

    # Assert allowed characters when non-empty
    allowed = set(string.ascii_letters + string.digits)
    for ch in s:
        assert ch in allowed


@pytest.mark.parametrize(
    "request_present, is_authenticated, is_following_result, expected",
    [
        (False, False, False, False),  # no request => False
        (True, False, False, False),  # not authenticated => False
        (True, True, True, True),  # authenticated and following => True
        (True, True, False, False),  # authenticated and not following => False
    ],
)
def test_get_following_various_request_states(request_present, is_authenticated, is_following_result, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # create target user object (the profile being inquired about)
    target_user = SimpleNamespace(username="target")

    # create fake requesting user with is_authenticated and is_following behavior
    def make_request_user():
        def is_following(obj):
            # we ignore obj content; return predetermined result
            return is_following_result

        return SimpleNamespace(is_authenticated=is_authenticated, is_following=is_following)

    if request_present:
        req_user = make_request_user()
        request = SimpleNamespace(user=req_user)
        context = {"request": request}
    else:
        context = {}

    # create dummy 'self' that mimics serializer instance which provides context
    dummy_self = SimpleNamespace(context=context)

    # Act
    result = get_following(dummy_self, target_user)

    # Assert
    assert isinstance(result, bool)
    assert result is expected
