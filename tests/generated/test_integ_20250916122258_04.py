import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import inspect
    import types
    import pytest
    from conduit.apps.profiles import models as profiles_models
    from conduit.apps.profiles import serializers as profiles_serializers
except ImportError:
    import pytest
    pytest.skip("Required application modules not available", allow_module_level=True)


class FakeQuerySet:
    def __init__(self, backing_set, kwargs):
        self._set = backing_set
        self._kwargs = kwargs or {}

    def exists(self):
        # If no filters, existence is whether any element present
        if not self._kwargs:
            return bool(self._set)
        for obj in self._set:
            ok = True
            for k, v in self._kwargs.items():
                # support nested lookups like user__username or slug variants
                parts = k.split("__")
                attr = obj
                try:
                    for p in parts:
                        attr = getattr(attr, p)
                except Exception:
                    ok = False
                    break
                if attr != v:
                    ok = False
                    break
            if ok:
                return True
        return False

    def count(self):
        return len(self._set)

    def all(self):
        return list(self._set)


class FakeManager:
    def __init__(self):
        self._set = set()

    def add(self, item):
        self._set.add(item)

    def remove(self, item):
        self._set.discard(item)

    def filter(self, **kwargs):
        return FakeQuerySet(self._set, kwargs)

    def clear(self):
        self._set.clear()


class SimpleUser:
    def __init__(self, username, image=None):
        self.username = username
        self.image = image
        # favorites used by favorite/has_favorited
        self.favorites = FakeManager()
        # following used by follow/is_following
        self.following = FakeManager()


class SimpleArticle:
    def __init__(self, slug=None, pk=None):
        self.slug = slug
        self.pk = pk
        self.id = pk


def _call_flexible(func, *pos_args):
    """
    Attempt calling func in a couple of common ways used by serializer methods:
    - as instance method: func(self_like, obj)
    - as function: func(obj)
    The first try will pass a dummy self if the function expects >1 positional.
    """
    sig = inspect.signature(func)
    params = list(sig.parameters)
    # If first parameter is 'self' or function expects >=2 parameters, provide dummy self
    try:
        if len(params) >= 2:
            dummy_self = types.SimpleNamespace(context={})
            return func(dummy_self, *pos_args)
        else:
            return func(*pos_args)
    except TypeError:
        # fallback attempt: try without dummy self
        return func(*pos_args)


@pytest.mark.parametrize(
    "user_image, expected",
    [
        ("http://example.com/pic.png", "http://example.com/pic.png"),
        (None, None),
        ("", ""),  # edge: empty string should be returned as-is if present on model
    ],
)
def test_get_image_various_inputs_returns_expected(user_image, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    fake_user = SimpleUser(username="alice", image=user_image)
    # Act
    result = _call_flexible(getattr(profiles_serializers, "get_image"))
    # If call without args returned a callable (bound method), try calling differently
    # But prefer direct invocation using our helper to handle multiple signatures
    try:
        res = _call_flexible(getattr(profiles_serializers, "get_image"), fake_user)
    except Exception as exc:
        pytest.fail(f"get_image raised unexpectedly: {exc}")
    # Assert
    assert res == expected
    assert (res is None) or isinstance(res, (str, type(user_image)))


def test_get_following_true_false_and_missing_request_context():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Target user to be serialized
    target = SimpleUser(username="target_user")
    # Requesting user who follows target
    requester = SimpleUser(username="requester")
    requester.following.add(target)  # simulate following relationship

    # Build a fake serializer-like self with context
    class FakeRequest:
        def __init__(self, user):
            self.user = user

    class FakeSerializer:
        def __init__(self, request):
            self.context = {"request": request}

    fake_serializer_following = FakeSerializer(FakeRequest(requester))
    fake_serializer_not_following = FakeSerializer(FakeRequest(SimpleUser("someone_else")))
    fake_serializer_no_request = FakeSerializer(request=None)
    fake_serializer_no_request.context = {}  # missing request key to simulate edge

    get_following_func = getattr(profiles_serializers, "get_following")

    # Act & Assert - requester follows target => True
    if len(inspect.signature(get_following_func).parameters) >= 2:
        res_true = get_following_func(fake_serializer_following, target)
        res_false = get_following_func(fake_serializer_not_following, target)
        # When context missing should gracefully return False (not raise)
        res_missing = get_following_func(fake_serializer_no_request, target)
    else:
        # fallback if the function takes only one param (unusual)
        res_true = get_following_func(target)
        res_false = get_following_func(target)
        res_missing = get_following_func(target)

    assert res_true is True
    assert res_false is False
    assert res_missing is False


@pytest.mark.parametrize(
    "initially_favorited, action_sequence, expected_final",
    [
        # normal flow: favorite then unfavorite -> False
        (False, ["favorite", "unfavorite"], False),
        # double favorite -> True
        (False, ["favorite", "favorite"], True),
        # unfavorite without favorite -> False (edge)
        (False, ["unfavorite"], False),
        # favorite twice then unfavorite once -> True
        (False, ["favorite", "favorite", "unfavorite"], True),
    ],
)
def test_favorite_unfavorite_and_has_favorited_behavior(initially_favorited, action_sequence, expected_final):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    fake_user = SimpleUser(username="reader")
    article = SimpleArticle(slug="an-article", pk=1)

    # If initially favorited set up
    if initially_favorited:
        fake_user.favorites.add(article)

    favorite_func = getattr(profiles_models, "favorite")
    unfavorite_func = getattr(profiles_models, "unfavorite")
    has_favorited_func = getattr(profiles_models, "has_favorited")

    # Bind methods to fake_user instance to simulate instance methods
    favorite_m = types.MethodType(favorite_func, fake_user)
    unfavorite_m = types.MethodType(unfavorite_func, fake_user)
    has_favorited_m = types.MethodType(has_favorited_func, fake_user)

    # Act
    for act in action_sequence:
        if act == "favorite":
            favorite_m(article)
        elif act == "unfavorite":
            # Should not raise if article not present
            unfavorite_m(article)
        else:
            pytest.fail(f"Unexpected action in sequence: {act}")

    # Assert
    final = has_favorited_m(article)
    assert isinstance(final, bool)
    assert final == expected_final

    # Also assert internal manager state is consistent with has_favorited
    present = article in fake_user.favorites._set
    assert present == expected_final


def test_favorite_with_invalid_article_raises_or_handles_gracefully():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    fake_user = SimpleUser(username="reader2")
    invalid_article = object()  # missing expected attributes
    favorite_func = getattr(profiles_models, "favorite")
    favorite_m = types.MethodType(favorite_func, fake_user)

    # Act / Assert: depending on implementation, this may raise AttributeError
    # or it may add the object to favorites. We assert it either raises AttributeError
    # or results in that object being present in favorites set.
    try:
        favorite_m(invalid_article)
    except AttributeError:
        # expected error path
        assert invalid_article not in fake_user.favorites._set
    else:
        # handled gracefully: ensure it was recorded or at least no crash
        assert invalid_article in fake_user.favorites._set or isinstance(invalid_article, object)
