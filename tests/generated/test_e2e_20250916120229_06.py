import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import string
    import json
    import jwt
    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.authentication.models import User
    from conduit.apps.authentication import models as auth_models_module
    from conduit.apps.authentication.renderers import UserJSONRenderer
except ImportError as e:
    import pytest
    pytest.skip("skipping tests because of ImportError: {}".format(e), allow_module_level=True)


@pytest.mark.parametrize("length", [1, 8, 32])
def test_generate_random_string_returns_expected_length_and_chars(length):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    allowed = set(string.ascii_letters + string.digits)

    # Act
    s = generate_random_string(length)

    # Assert
    assert isinstance(s, str)
    assert len(s) == length
    assert set(s).issubset(allowed)


def test_user_token_is_valid_jwt_and_fails_with_wrong_secret(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a lightweight User instance without DB operations
    user = User()
    # set a reproducible primary key for payload predictability
    user.pk = 42

    # Ensure the module uses a known SECRET_KEY for token generation
    monkeypatch.setattr(auth_models_module.settings, "SECRET_KEY", "supersecret-test-key", raising=False)

    # Act
    token = user.token  # property that wraps _generate_jwt_token

    # Assert general token properties
    assert isinstance(token, (str, bytes))

    # Normalize token to str for decoding depending on pyjwt version
    token_str = token.decode("utf-8") if isinstance(token, bytes) else token

    # Decode with correct secret -> should succeed and contain id == 42
    payload = jwt.decode(token_str, "supersecret-test-key", algorithms=["HS256"])
    assert isinstance(payload, dict)
    assert payload.get("id") == 42
    assert "exp" in payload

    # Now ensure that decoding with the wrong secret raises an exception (error path)
    wrong_secret = "wrongkey"
    with pytest.raises(Exception) as excinfo:
        jwt.decode(token_str, wrong_secret, algorithms=["HS256"])
    # Prefer concrete jwt exception types if available
    jwt_exc_types = (jwt.InvalidSignatureError, getattr(jwt, "exceptions", type("E", (), {})).InvalidSignatureError if hasattr(jwt, "exceptions") and hasattr(jwt.exceptions, "InvalidSignatureError") else Exception)
    assert isinstance(excinfo.value, Exception)


@pytest.mark.parametrize(
    "input_data, expected_contains",
    [
        ({"user": {"email": "a@b.com", "username": "bob"}}, '"user"'),
        ({}, '"user"'),
    ],
)
def test_user_json_renderer_renders_json_bytes_and_roundtrips(input_data, expected_contains):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()

    # Act
    rendered = renderer.render(input_data)

    # Assert
    assert isinstance(rendered, (bytes, str))
    rendered_str = rendered.decode("utf-8") if isinstance(rendered, bytes) else rendered
    # Must be JSON parsable
    parsed = json.loads(rendered_str)
    assert isinstance(parsed, dict)
    # Ensure the expected key or structure exists in the rendered output
    assert expected_contains.strip('"') in rendered_str
    # Roundtrip: serialized back should match original top-level keys where possible
    # If input had 'user' key, ensure it's present after rendering
    if "user" in input_data:
        assert parsed.get("user") == input_data["user"]
