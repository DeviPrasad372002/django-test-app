import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import json
    import random

    import pytest

    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.authentication.serializers import RegistrationSerializer
    from conduit.apps.core.utils import generate_random_string
    from rest_framework import exceptions as drf_exceptions
except ImportError:
    import pytest
    pytest.skip("skipping tests because required packages or project modules are not available", allow_module_level=True)


@pytest.mark.parametrize(
    "input_data, expected_user_payload",
    [
        # normal case: plain user dict should be wrapped under "user"
        ({"email": "alice@example.com", "username": "alice"}, {"email": "alice@example.com", "username": "alice"}),
        # edge case: already wrapped payload should remain idempotently wrapped (no double-wrap)
        ({"user": {"email": "bob@example.com", "username": "bob"}}, {"email": "bob@example.com", "username": "bob"}),
    ],
)
def test_user_json_renderer_renders_user_wrapped_json(input_data, expected_user_payload):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()

    # Act
    rendered_bytes = renderer.render(input_data)

    # Assert
    assert isinstance(rendered_bytes, (bytes, bytearray))
    decoded = rendered_bytes.decode("utf-8")
    parsed = json.loads(decoded)

    # The public contract of the renderer is to return a JSON object with a top-level "user" key
    assert "user" in parsed
    assert parsed["user"] == expected_user_payload


@pytest.mark.parametrize(
    "password, password2, should_be_valid",
    [
        # normal case: matching passwords should pass validation (no create/save attempted here)
        ("s3cret", "s3cret", True),
        # error path: mismatched passwords should fail validation
        ("s3cret", "wrong", False),
    ],
)
def test_registration_serializer_password_matching_and_mismatch(password, password2, should_be_valid):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    data = {
        "username": "tester",
        "email": "tester@example.com",
        "password": password,
        "password2": password2,
    }
    serializer = RegistrationSerializer(data=data)

    # Act
    is_valid = serializer.is_valid()

    # Assert
    if should_be_valid:
        assert is_valid is True
        assert serializer.errors == {}
        # check validated_data contains expected keys and types
        validated = serializer.validated_data
        assert isinstance(validated.get("username"), str)
        assert isinstance(validated.get("email"), str)
    else:
        assert is_valid is False
        # error message should mention password mismatch in some form
        errors_str = str(serializer.errors).lower()
        assert "password" in errors_str or "match" in errors_str or "password2" in errors_str


@pytest.mark.parametrize("length", [1, 6, 10])
def test_generate_random_string_deterministic_with_monkeypatched_choice(length, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Make random.choice deterministic by always returning the first element of the sequence.
    monkeypatch.setattr(random, "choice", lambda seq: seq[0])

    # Act
    result = generate_random_string(length)

    # Assert
    assert isinstance(result, str)
    assert len(result) == length
    # Because choice always returns seq[0], the result should be that character repeated length times
    # Use the same source of allowed characters as the implementation does not need to be known exactly;
    # we just assert it is a repetition of the first character.
    if len(result) > 0:
        first_char = result[0]
        assert result == first_char * length
