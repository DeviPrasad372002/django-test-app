import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest
from unittest.mock import MagicMock

try:
    import conduit.apps.articles.signals as signals_module
    from conduit.apps.articles.signals import add_slug_to_article_if_not_exists
    from conduit.apps.authentication.backends import JWTAuthentication
    from conduit.apps.articles.serializers import ArticleSerializer
    import conduit.apps.profiles.models as profiles_models
    from rest_framework.exceptions import AuthenticationFailed
except ImportError:
    pytest.skip("Required application modules or third-party libraries not available", allow_module_level=True)


@pytest.mark.parametrize(
    "initial_title, initial_slug, slugify_return, gen_rand_return, expected_slug, should_save",
    [
        # Normal case: title present -> slug created from title
        ("Hello World", None, "hello-world", None, "hello-world", True),
        # Edge case: title empty -> generate_random_string used
        ("", None, None, "randslug", "randslug", True),
        # Error/path: slug already exists -> no change, no save
        ("Existing", "exists-slug", "should-not-be-used", "should-not-be-used", "exists-slug", False),
    ],
)
def test_add_slug_to_article_if_not_exists_variants(
    # Arrange-Act-Assert: generated by ai-testgen
    initial_title, initial_slug, slugify_return, gen_rand_return, expected_slug, should_save, monkeypatch
):
    # Arrange
    class DummyArticle:
        def __init__(self, title, slug):
            self.title = title
            self.slug = slug
            self.saved = False
            self.save_calls = []

        def save(self, *args, **kwargs):
            self.saved = True
            self.save_calls.append((args, kwargs))

    article = DummyArticle(initial_title, initial_slug)

    # Monkeypatch the utilities the signal handler uses inside its module
    if slugify_return is not None:
        monkeypatch.setattr(signals_module, "slugify", lambda s: slugify_return)
    if gen_rand_return is not None:
        monkeypatch.setattr(signals_module, "generate_random_string", lambda: gen_rand_return)

    # Act
    # The signal handler signature is (sender, instance, **kwargs)
    add_slug_to_article_if_not_exists(sender=None, instance=article)

    # Assert
    assert article.slug == expected_slug
    if should_save:
        assert article.saved is True
        # Expect that save was called with update_fields containing 'slug' in at least one call
        assert any("slug" in (kwargs.get("update_fields") or []) for (_, kwargs) in article.save_calls)
    else:
        assert article.saved is False
        assert article.save_calls == []


def test_jwtauthenticate_calls_credentials_and_handles_missing_or_bad_token(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()

    class DummyRequest:
        def __init__(self, header=None):
            self.META = {}
            if header is not None:
                self.META["HTTP_AUTHORIZATION"] = header

    recorded = {}

    def fake_authenticate_credentials(token):
        recorded["token"] = token
        return ("fake_user_obj", token)

    # Normal case: header present -> _authenticate_credentials called and returned tuple propagated
    monkeypatch.setattr(JWTAuthentication, "_authenticate_credentials", staticmethod(fake_authenticate_credentials))
    req_with = DummyRequest(header="Token secret-token-123")
    # Act
    result = auth.authenticate(req_with)
    # Assert
    assert result == ("fake_user_obj", "secret-token-123")
    assert recorded["token"] == "secret-token-123"

    # Edge case: missing header -> authenticate returns None (no authentication attempted)
    req_missing = DummyRequest(header=None)
    result_none = auth.authenticate(req_missing)
    assert result_none is None

    # Error path: _authenticate_credentials raises AuthenticationFailed -> exception propagates
    def raise_auth_fail(token):
        raise AuthenticationFailed("bad token")

    monkeypatch.setattr(JWTAuthentication, "_authenticate_credentials", staticmethod(raise_auth_fail))
    req_bad = DummyRequest(header="Token ought-to-fail")
    with pytest.raises(AuthenticationFailed):
        auth.authenticate(req_bad)


@pytest.mark.parametrize(
    "favorited_return, favorites_count",
    [
        # normal: favorited True, small count
        (True, 3),
        # normal: favorited False, zero count
        (False, 0),
        # edge: large favorites count
        (True, 12345),
    ],
)
def test_article_serializer_favorited_and_count(monkeypatch, favorited_return, favorites_count):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake article object with a favorites manager that has count()
    class FakeArticle:
        def __init__(self, count):
            self.favorites = MagicMock()
            self.favorites.count.return_value = count
            self.slug = "test-slug"

    fake_article = FakeArticle(favorites_count)

    # The serializer's get_favorited likely calls a helper in profiles.models; monkeypatch it
    monkeypatch.setattr(profiles_models, "has_favorited", lambda article, user: favorited_return)

    # Create serializer with a fake request context to provide the user
    fake_user = MagicMock()
    serializer = ArticleSerializer(context={"request": MagicMock(user=fake_user)})

    # Act
    got_favorited = serializer.get_favorited(fake_article)
    got_count = serializer.get_favorites_count(fake_article)

    # Assert
    assert isinstance(got_favorited, bool)
    assert got_favorited == favorited_return
    assert isinstance(got_count, int)
    assert got_count == favorites_count
