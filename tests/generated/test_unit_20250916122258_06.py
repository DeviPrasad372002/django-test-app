import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import jwt
    import json
    import pytest
    from unittest.mock import Mock
    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication.renderers import UserJSONRenderer
except ImportError:
    import pytest
    pytest.skip("Required third-party modules or application modules not available", allow_module_level=True)


@pytest.mark.parametrize("user_id", [1, 0, 99999])
def test__generate_jwt_token_returns_decodable_token(monkeypatch, user_id):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Ensure a stable SECRET_KEY for encoding/decoding within the module under test
    monkeypatch.setattr(auth_models.settings, "SECRET_KEY", "TEST_SECRET_KEY", raising=False)

    # Act
    token = auth_models._generate_jwt_token(user_id)

    # Assert
    assert isinstance(token, str)
    # Decode using the same secret to ensure payload integrity
    payload = jwt.decode(token, auth_models.settings.SECRET_KEY, algorithms=["HS256"])
    # The payload should contain an identifier for the user; accept int/str forms
    assert str(payload.get("id")) == str(user_id)
    # Ensure an expiration timestamp exists and is an integer
    assert isinstance(payload.get("exp"), int)


@pytest.mark.parametrize(
    ("email_value", "expected"),
    [
        ("user@example.com", "user@example.com"),
        (None, ""),
        ("", ""),
    ],
)
def test_user_get_short_name_various_email_values(email_value, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    user = auth_models.User(email=email_value)

    # Act
    short = user.get_short_name()

    # Assert
    assert isinstance(short, str)
    assert short == expected


def test_user_token_property_uses_internal_generator(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    fake_token = "FAKE.JWT.TOKEN"
    mock_generator = Mock(return_value=fake_token)
    monkeypatch.setattr(auth_models, "_generate_jwt_token", mock_generator, raising=False)
    user = auth_models.User(id=42)

    # Act
    result = user.token

    # Assert
    assert result == fake_token
    mock_generator.assert_called_once_with(42)


@pytest.mark.parametrize(
    ("input_data", "expect_error"),
    [
        ({"id": 1, "email": "x@x.com"}, False),
        (object(), True),
    ],
)
def test_userjsonrenderer_render_success_and_error(input_data, expect_error):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()

    # Act / Assert
    if expect_error:
        with pytest.raises(TypeError):
            renderer.render(input_data)
    else:
        output = renderer.render(input_data)
        assert isinstance(output, (bytes, bytearray))
        decoded = json.loads(output.decode("utf-8"))
        # The JSON should include a "user" wrapper or at least the serialized content
        assert "user" in decoded
        # Ensure the wrapped content matches input data when input is a dict
        assert decoded["user"] == input_data
