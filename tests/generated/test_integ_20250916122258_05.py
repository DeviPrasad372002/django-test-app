import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import json
    import pytest
    from target.conduit.apps.articles.renderers import ArticleJSONRenderer, CommentJSONRenderer
    from target.conduit.apps.core.exceptions import core_exception_handler, _handle_generic_error, _handle_not_found_error
    from rest_framework.exceptions import NotFound
    from rest_framework.response import Response
except ImportError:
    import pytest  # type: ignore
    pytest.skip("skipping integration tests - required modules not available", allow_module_level=True)


@pytest.mark.parametrize(
    "input_data, expected_top_key, expect_empty",
    [
        ({"title": "Test"}, "article", False),
        ([{"title": "A"}, {"title": "B"}], "articles", False),
        ({"errors": {"field": ["bad"]}}, "errors", False),
        (None, None, True),
    ],
)
def test_article_json_renderer_various_shapes(input_data, expected_top_key, expect_empty):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()
    # Act
    output_bytes = renderer.render(input_data, accepted_media_type=None, renderer_context=None)
    # Assert
    assert isinstance(output_bytes, (bytes, bytearray))
    if expect_empty:
        assert output_bytes == b""  # renderer should return empty bytes for None input
        return
    decoded = json.loads(output_bytes.decode("utf-8"))
    assert isinstance(decoded, dict)
    # when 'errors' present, renderer should pass through the errors key
    if isinstance(input_data, dict) and "errors" in input_data:
        assert "errors" in decoded
        assert decoded["errors"] == input_data["errors"]
    else:
        assert expected_top_key in decoded
        assert decoded[expected_top_key] == input_data


@pytest.mark.parametrize(
    "input_data, expected_top_key, expect_empty",
    [
        ({"body": "Nice"}, "comment", False),
        ([{"body": "c1"}, {"body": "c2"}], "comments", False),
        ({"errors": {"detail": "nope"}}, "errors", False),
        (None, None, True),
    ],
)
def test_comment_json_renderer_various_shapes(input_data, expected_top_key, expect_empty):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = CommentJSONRenderer()
    # Act
    output_bytes = renderer.render(input_data, accepted_media_type=None, renderer_context=None)
    # Assert
    assert isinstance(output_bytes, (bytes, bytearray))
    if expect_empty:
        assert output_bytes == b""
        return
    decoded = json.loads(output_bytes.decode("utf-8"))
    assert isinstance(decoded, dict)
    if isinstance(input_data, dict) and "errors" in input_data:
        assert "errors" in decoded
        assert decoded["errors"] == input_data["errors"]
    else:
        assert expected_top_key in decoded
        assert decoded[expected_top_key] == input_data


@pytest.mark.parametrize(
    "exc, expected_status, expect_detail_matches_exception",
    [
        (NotFound(detail="not found item"), 404, True),
        (Exception("something bad"), 500, False),
    ],
)
def test_core_exception_handler_handles_not_found_and_generic(exc, expected_status, expect_detail_matches_exception):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: use the specific handler functions to compare outputs for NotFound path
    # Act
    response = core_exception_handler(exc, {"request": None})
    # Assert common
    assert isinstance(response, Response)
    assert response.status_code == expected_status
    assert isinstance(response.data, dict)
    # For NotFound we expect the not-found handler to produce a response containing the exception message
    if isinstance(exc, NotFound):
        # Ensure the dedicated helper produces the same result shape and content
        direct = _handle_not_found_error(exc)
        assert isinstance(direct, Response)
        assert direct.status_code == 404
        assert direct.data == response.data
        # Expect the returned payload to include the textual detail from the exception
        # The handler is expected to nest the message under errors -> detail
        assert "errors" in response.data
        assert isinstance(response.data["errors"], dict)
        assert response.data["errors"].get("detail") == str(exc.detail)
    else:
        # Generic exceptions should be handled by the generic handler producing a 500-like response
        generic = _handle_generic_error(exc)
        assert isinstance(generic, Response)
        assert generic.status_code == 500
        # The core handler should delegate to the generic handler for unknown exceptions
        assert generic.status_code == response.status_code
        assert isinstance(response.data.get("errors"), dict)
        # We don't assert the exact error message for generic errors, but ensure structure is present
        assert "errors" in response.data and isinstance(response.data["errors"], dict)
