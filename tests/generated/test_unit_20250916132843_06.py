import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import json
import types
import pytest

try:
    from conduit.apps.authentication.backends import JWTAuthentication
    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication.models import User
    from conduit.apps.authentication.renderers import UserJSONRenderer
    from rest_framework import exceptions as drf_exceptions
except ImportError as e:
    pytest.skip(f"Required project modules not available: {e}", allow_module_level=True)


def test_user_get_full_and_short_name_various():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    cases = [
        ("alice@example.com", "alice@example.com"),
        ("", ""),
        (None, None),
    ]

    for email, expected in cases:
        # Act
        user = User()
        # Some User implementations expect attribute 'email' present; set directly
        user.email = email

        full = user.get_full_name() if hasattr(user, "get_full_name") else None
        short = user.get_short_name() if hasattr(user, "get_short_name") else None

        # Assert
        assert full == expected
        assert short == expected


@pytest.mark.parametrize("encoded_value", ["fake.jwt.string", b"fake.jwt.bytes"])
def test_user_token_uses_jwt_encode(monkeypatch, encoded_value):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    captured = {}

    def fake_encode(payload, key, algorithm="HS256"):
        # capture payload for assertion, return the provided encoded_value
        captured["payload"] = payload
        captured["key"] = key
        captured["algorithm"] = algorithm
        return encoded_value

    monkeypatch.setattr(auth_models.jwt, "encode", fake_encode)

    user = User()
    # ensure we have an identifier attribute that _generate_jwt_token may include
    user.pk = 42
    user.id = 42
    user.email = "tester@example.com"

    # Act
    token = user.token  # property that should call _generate_jwt_token which uses jwt.encode

    # Assert
    # token should be a str; if jwt.encode returned bytes, token property may decode it to str
    assert isinstance(token, str)
    assert "fake.jwt" in token
    # payload should include a user_id pointing to the created user's id/pk
    assert "payload" in captured
    payload = captured["payload"]
    # payload is expected to be a dict containing user_id (typical implementation)
    assert isinstance(payload, dict)
    assert payload.get("user_id") in (user.pk, user.id)


def test_userjsonrenderer_render_normal_and_none():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()

    # normal case
    data = {"email": "bob@example.com", "username": "bob"}
    # Act
    rendered = renderer.render(data)
    # Assert
    assert isinstance(rendered, (bytes, str))
    parsed = json.loads(rendered.decode() if isinstance(rendered, bytes) else rendered)
    assert "user" in parsed
    assert parsed["user"] == data

    # edge case: None should be handled gracefully (commonly returns empty bytes)
    rendered_none = renderer.render(None)
    # Assert
    assert rendered_none in (b"", "")


def test_jwtauthenticate_handles_invalid_headers():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()

    class DummyRequest:
        def __init__(self, header_value=None):
            self.META = {}
            if header_value is not None:
                self.META["HTTP_AUTHORIZATION"] = header_value

    # Act / Assert: missing header should return None (no authentication attempted)
    req_no_header = DummyRequest()
    result = auth.authenticate(req_no_header)
    assert result is None

    # Act / Assert: header with only scheme should raise AuthenticationFailed
    req_bad = DummyRequest("Token")
    with pytest.raises(drf_exceptions.AuthenticationFailed):
        auth.authenticate(req_bad)
