import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    import pytest
    from unittest import mock
    from types import SimpleNamespace
    from conduit.apps.articles.signals import add_slug_to_article_if_not_exists
    from conduit.apps.core import utils as core_utils
    from conduit.apps.profiles import serializers as profiles_serializers
except ImportError:
    import pytest
    pytest.skip("requires project modules", allow_module_level=True)


@pytest.mark.parametrize(
    "title,initial_slug,rand_val,expect_saved",
    [
        ("Hello World", None, "RND123", True),     # normal title -> slug set and saved
        ("", None, "RND456", True),                # empty title -> fallback slug via random -> saved
        ("Existing", "already-there", "IGNORED", False),  # slug already exists -> do not save
    ],
)
def test_add_slug_to_article_if_not_exists_sets_slug_and_saves(monkeypatch, title, initial_slug, rand_val, expect_saved):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyArticle:
        def __init__(self, title, slug):
            self.title = title
            self.slug = slug
            self.saved = False

        def save(self):
            # side effect to detect save calls
            self.saved = True

    article = DummyArticle(title=title, slug=initial_slug)

    # Ensure deterministic random string when code falls back to generating one
    monkeypatch.setattr(core_utils, "generate_random_string", lambda *a, **k: rand_val)

    # Act
    # The real signal receiver often accepts (sender, instance, created, **kwargs)
    # We call it in the same manner as Django would.
    add_slug_to_article_if_not_exists(sender=SimpleNamespace(), instance=article, created=True)

    # Assert
    if expect_saved:
        assert article.saved is True, "Expected the article to be saved when slug was missing"
        assert isinstance(article.slug, str), "Slug should be a string"
        assert article.slug != "", "Slug should not be empty when saved"
        # If title provided, expect part of the slug to reflect the title when possible
        if title:
            # slug should at least contain a lowercased fragment of the title or the random fallback
            assert (title.split()[0].lower() in article.slug) or (rand_val in article.slug)
    else:
        assert article.saved is False, "Expected no save when slug already existed"
        assert article.slug == "already-there"


@pytest.mark.parametrize(
    "is_following_return,image_value,request_user_is_anonymous,expected_following,expected_image",
    [
        (True, "http://example.com/img.png", False, True, "http://example.com/img.png"),   # following + image present
        (False, "", False, False, ""),                                                     # not following + empty image
        (True, None, True, False, None),                                                   # anonymous user -> not following, image None preserved
    ],
)
def test_get_following_and_get_image_behaviour(monkeypatch, is_following_return, image_value, request_user_is_anonymous, expected_following, expected_image):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a mock profile-like object that serializers expect
    class MockProfile:
        def __init__(self, image, follow_ret):
            self.image = image
            self._follow_ret = follow_ret

        # different implementations might name method is_following or is_followed_by;
        # provide both and have them return the same sentinel value.
        def is_following(self, user):
            return self._follow_ret

        def is_followed_by(self, user):
            return self._follow_ret

    profile_obj = MockProfile(image=image_value, follow_ret=is_following_return)

    # Create a mock request and user to inject into serializer context
    mock_user = SimpleNamespace(is_authenticated=not request_user_is_anonymous)
    mock_request = SimpleNamespace(user=mock_user)

    # Determine how to call the serializer helper functions.
    # Some implementations define get_following/get_image as module-level functions,
    # others as methods on a ProfileSerializer class. Handle both.
    def call_possible_method_or_function(name, obj, context):
        # Try module-level function first
        if hasattr(profiles_serializers, name):
            func = getattr(profiles_serializers, name)
            # If it's a function expecting (obj,) or (self,obj), try calling in a safe way.
            try:
                # If it's a plain function signature (obj,) - call directly
                return func(obj)
            except TypeError:
                # Assume function expects a serializer-like self with context
                fake_self = SimpleNamespace(context=context)
                return func(fake_self, obj)
        # Fallback to ProfileSerializer class method
        SerializerClass = getattr(profiles_serializers, "ProfileSerializer", None)
        if SerializerClass is None:
            raise AssertionError("Cannot find function or ProfileSerializer to test {}".format(name))
        # Instantiate serializer with context and call method
        serializer_instance = SerializerClass(context=context)
        method = getattr(serializer_instance, name)
        return method(profile_obj)

    # Act
    context = {"request": mock_request}
    following_result = call_possible_method_or_function("get_following", profile_obj, context)
    image_result = call_possible_method_or_function("get_image", profile_obj, context)

    # Assert - concrete outputs and types
    assert isinstance(following_result, bool), "get_following should return a boolean"
    assert following_result == expected_following

    # image_result might be None or str depending on implementation; assert exact expected
    assert image_result == expected_image
