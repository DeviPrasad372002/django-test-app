import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import json
    import pytest

    from conduit.apps.articles.renderers import ArticleJSONRenderer, CommentJSONRenderer
    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.articles.relations import TagRelatedField
except ImportError:
    import pytest
    pytest.skip("Required modules for E2E tests are not available", allow_module_level=True)


def test_article_json_renderer_wraps_article_and_list_returns_bytes_and_expected_json():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()
    single_article = {"title": "Deterministic Testing", "body": "Ensure output is JSON serializable"}
    articles_list = [
        {"title": "First", "body": "one"},
        {"title": "Second", "body": "two"},
    ]

    # Act
    single_bytes = renderer.render(single_article, accepted_media_type="application/json", renderer_context=None)
    list_bytes = renderer.render(articles_list, accepted_media_type="application/json", renderer_context=None)

    # Assert
    assert isinstance(single_bytes, (bytes, bytearray))
    assert isinstance(list_bytes, (bytes, bytearray))

    single_decoded = json.loads(single_bytes.decode("utf-8"))
    list_decoded = json.loads(list_bytes.decode("utf-8"))

    # The renderer should wrap a single article under the "article" key
    assert isinstance(single_decoded, dict)
    assert "article" in single_decoded
    assert single_decoded["article"]["title"] == "Deterministic Testing"
    assert isinstance(single_decoded["article"]["body"], str)

    # The renderer should wrap a list under the "articles" key (public API expectation)
    assert isinstance(list_decoded, dict)
    # Accept either "articles" or "articles" list inside "articles" wrapper depending on implementation
    assert "articles" in list_decoded
    assert isinstance(list_decoded["articles"], list)
    assert len(list_decoded["articles"]) == 2
    assert list_decoded["articles"][0]["title"] == "First"


def test_user_and_comment_json_renderers_wrap_payloads_correctly():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    u_renderer = UserJSONRenderer()
    c_renderer = CommentJSONRenderer()

    user_payload = {"email": "a@example.com", "username": "alice"}
    comment_payload = {"body": "Nice article", "id": 123}

    # Act
    user_bytes = u_renderer.render(user_payload, accepted_media_type="application/json", renderer_context=None)
    comment_bytes = c_renderer.render(comment_payload, accepted_media_type="application/json", renderer_context=None)

    # Assert
    assert isinstance(user_bytes, (bytes, bytearray))
    assert isinstance(comment_bytes, (bytes, bytearray))

    user_obj = json.loads(user_bytes.decode("utf-8"))
    comment_obj = json.loads(comment_bytes.decode("utf-8"))

    # Public API: User renderer should put the payload under a "user" key
    assert isinstance(user_obj, dict)
    assert "user" in user_obj
    assert user_obj["user"]["username"] == "alice"
    assert user_obj["user"]["email"] == "a@example.com"

    # Public API: Comment renderer should put the payload under a "comment" key
    assert isinstance(comment_obj, dict)
    assert "comment" in comment_obj
    assert comment_obj["comment"]["body"] == "Nice article"
    assert comment_obj["comment"]["id"] == 123


def test_article_json_renderer_raises_type_error_for_non_serializable_input():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()

    class NonSerializable:
        pass

    bad_payload = {"weird": NonSerializable()}

    # Act / Assert: json.dumps should raise a TypeError for non-serializable objects
    with pytest.raises(TypeError):
        renderer.render(bad_payload, accepted_media_type="application/json", renderer_context=None)


def test_tag_related_field_to_representation_returns_name_and_handles_missing_name_attribute():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    field = TagRelatedField()

    class TagLike:
        def __init__(self, name):
            self.name = name

    tagged = TagLike("python")

    # Act
    rep = field.to_representation(tagged)

    # Assert normal case
    assert isinstance(rep, str)
    assert rep == "python"

    # Edge / error case: object without name attribute should raise AttributeError
    class NoName:
        pass

    with pytest.raises(AttributeError):
        field.to_representation(NoName())
