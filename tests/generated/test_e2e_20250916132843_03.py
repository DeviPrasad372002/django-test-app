import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest
import json
import random

try:
    from target.conduit.apps.core.utils import generate_random_string
    from target.conduit.apps.authentication.signals import create_related_profile
    from target.conduit.apps.authentication.renderers import UserJSONRenderer
    from target.conduit.apps.profiles.models import follow, unfollow, is_following
except ImportError:
    pytest.skip("Required project modules are not available", allow_module_level=True)


def test_generate_random_string_deterministic_and_lengths(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    expected_char = "Z"
    monkeypatch.setattr(random, "choice", lambda seq: expected_char)
    lengths = [1, 4, 0]

    for length in lengths:
        # Act
        result = generate_random_string(length)

        # Assert
        assert isinstance(result, str)
        assert len(result) == length
        assert result == expected_char * length


def test_userjsonrenderer_render_outputs_json_bytes():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()
    input_data = {"user": {"email": "alice@example.com", "username": "alice", "token": "secret-token"}}
    # Act
    output = renderer.render(input_data, renderer_context={})

    # Assert
    assert isinstance(output, (bytes, bytearray))
    decoded = output.decode("utf-8")
    parsed = json.loads(decoded)
    assert isinstance(parsed, dict)
    assert "user" in parsed
    assert parsed["user"]["email"] == "alice@example.com"
    assert parsed["user"]["username"] == "alice"
    assert parsed["user"]["token"] == "secret-token"


def test_create_related_profile_calls_profile_create(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    created_calls = []

    class FakeProfileManager:
        @staticmethod
        def create(**kwargs):
            created_calls.append(kwargs)
            # Simulate returning a profile instance
            return {"fake_profile_for": kwargs.get("user")}

    class FakeProfile:
        objects = FakeProfileManager()

    # Import the module where create_related_profile is defined and patch its Profile reference
    import importlib

    module = importlib.import_module("target.conduit.apps.authentication.signals")
    monkeypatch.setattr(module, "Profile", FakeProfile)

    class FakeUser:
        def __init__(self, username):
            self.username = username

        def __repr__(self):
            return f"<FakeUser {self.username}>"

    fake_user = FakeUser("bob")

    # Act
    # The real signal handler signature is (sender, instance, created, **kwargs)
    create_related_profile(sender=None, instance=fake_user, created=True)

    # Assert
    assert len(created_calls) == 1
    assert "user" in created_calls[0]
    assert created_calls[0]["user"] is fake_user


def test_follow_unfollow_and_is_following_behavior():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class FakeFollowingManager:
        def __init__(self):
            self._set = set()

        def add(self, profile):
            self._set.add(profile)

        def remove(self, profile):
            self._set.discard(profile)

        def all(self):
            return list(self._set)

    class FakeProfileObj:
        def __init__(self, name):
            self.name = name
            # the following manager holds profiles this object follows
            self.following = FakeFollowingManager()

        def __repr__(self):
            return f"<Profile {self.name}>"

    follower = FakeProfileObj("follower")
    followee = FakeProfileObj("followee")

    # Pre-assert not following
    assert followee not in follower.following.all()
    assert is_following(follower, followee) is False

    # Act - follow
    follow(follower, followee)

    # Assert - now following
    assert followee in follower.following.all()
    assert is_following(follower, followee) is True

    # Act - unfollow
    unfollow(follower, followee)

    # Assert - not following anymore
    assert followee not in follower.following.all()
    assert is_following(follower, followee) is False

    # Edge: unfollow when not following should not raise and should remain False
    unfollow(follower, followee)
    assert is_following(follower, followee) is False
