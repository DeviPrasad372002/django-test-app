import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    import pytest
    import jwt as _jwt  # third-party guard
    from unittest import mock
except ImportError:
    import pytest
    pytest.skip("pytest and jwt are required for these tests", allow_module_level=True)


@pytest.mark.parametrize(
    "initial_slug, created, expect_changed",
    [
        (None, True, True),       # new instance without slug -> slug should be added
        ("existing-slug", True, False),  # already has slug -> should remain unchanged
        (None, False, True),      # created False but slug missing -> signal may still add slug depending on implementation
    ],
)
def test_add_slug_to_article_if_not_exists(initial_slug, created, expect_changed):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    try:
        from conduit.apps.articles import signals as signals_module
        from conduit.apps.articles.signals import add_slug_to_article_if_not_exists
    except ImportError:
        pytest.skip("articles.signals not importable")

    class DummyArticle:
        def __init__(self, title, slug):
            self.title = title
            self.slug = slug
            self._saved = False

        def save(self, *args, **kwargs):
            # emulate model save being called by signal
            self._saved = True

    dummy = DummyArticle(title="Hello World!", slug=initial_slug)

    # Make random suffix deterministic
    monkey_random = "RND123"
    # Act: patch the generate_random_string used in the signals module
    # Assert inside finally by checking dummy.slug contents/state
    original_gen = getattr(signals_module, "generate_random_string", None)
    try:
        setattr(signals_module, "generate_random_string", lambda length=6: monkey_random)
        # Call the signal handler just like Django would: sender, instance, created
        add_slug_to_article_if_not_exists(sender=None, instance=dummy, created=created)
    finally:
        # restore if it existed
        if original_gen is not None:
            setattr(signals_module, "generate_random_string", original_gen)

    # Assert
    if expect_changed:
        assert isinstance(dummy.slug, str) and dummy.slug != "" , "slug should be a non-empty string"
        # Ensure the deterministic random piece is present
        assert monkey_random in dummy.slug, "slug should include the generated random string"
        # If save() was called by the signal handler, _saved will be True
        assert dummy._saved in (True, False)  # state change may or may not be performed; at least attribute exists
    else:
        assert dummy.slug == "existing-slug"


@pytest.mark.parametrize(
    "title, slug, expected_str",
    [
        ("My Article Title", None, "My Article Title"),
        ("", "my-article", "my-article"),
        (None, "fallback-slug", "fallback-slug"),
        (None, None, ""),  # edge: no title and no slug -> expect empty string
    ],
)
def test_article___str__returns_title_or_slug(title, slug, expected_str):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    try:
        from conduit.apps.articles.models import Article
    except ImportError:
        pytest.skip("articles.models.Article not importable")

    # Act
    # Instantiate without saving to DB; Django model __str__ should work on attributes
    article = Article()
    # set attributes directly to avoid DB requirements
    setattr(article, "title", title)
    setattr(article, "slug", slug)
    result = str(article)

    # Assert
    assert isinstance(result, str)
    assert result == expected_str


def test_jwtauthentication_authenticate_success_and_missing_header(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    try:
        from conduit.apps.authentication import backends as backends_module
    except ImportError:
        pytest.skip("authentication.backends not importable")

    auth = backends_module.JWTAuthentication()

    # Successful auth path
    # Create a fake request with Authorization header
    class Req:
        META = {"HTTP_AUTHORIZATION": "Token faketoken"}

    request_with_token = Req()

    # Make jwt.decode deterministic within the backends module
    def fake_decode(token, key, algorithms=None):
        # emulate payload as produced by the app
        return {"id": 123}

    # Create a mock user to be returned by the User manager
    mock_user = mock.Mock(name="UserMock")

    # Patch decode and User.objects.get
    # Ensure we patch the jwt referenced by the backends module
    if hasattr(backends_module, "jwt"):
        monkeypatch.setattr(backends_module.jwt, "decode", fake_decode)
    else:
        # If the module didn't import jwt under that name, try patching global jwt
        import jwt as global_jwt
        monkeypatch.setattr(global_jwt, "decode", fake_decode)

    # Patch the User.objects.get to return our mock_user
    if hasattr(backends_module, "User"):
        # Monkeypatch the manager's get method
        try:
            monkeypatch.setattr(backends_module.User.objects, "get", lambda *args, **kwargs: mock_user)
        except Exception:
            # As a fallback, monkeypatch the User attribute to a dummy with objects.get
            class DummyObjects:
                @staticmethod
                def get(*args, **kwargs):
                    return mock_user

            monkeypatch.setattr(backends_module, "User", mock.Mock(objects=DummyObjects()))

    # Act
    result = auth.authenticate(request_with_token)

    # Assert success path: expect a tuple where first item is the resolved user (common DRF pattern)
    assert result is not None, "Expected authentication to succeed and not return None"
    assert isinstance(result, tuple), "Expected authenticate to return a tuple (user, token)"
    assert result[0] is mock_user

    # Missing header path: no Authorization should result in None
    class ReqNoAuth:
        META = {}

    request_no_auth = ReqNoAuth()
    result_no_auth = auth.authenticate(request_no_auth)
    assert result_no_auth is None, "Expected None when no Authorization header is provided"
