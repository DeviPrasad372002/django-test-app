import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest as _pytest
_pytest.skip('generator: banned private imports detected; skipping module', allow_module_level=True)

try:
    import pytest
    from unittest import mock

    # target imports
    from conduit.apps.articles import signals as article_signals
    from conduit.apps.articles import relations as article_relations
    from conduit.apps.articles import models as article_models
    from conduit.apps.articles.views import TagListAPIView
    from rest_framework.test import APIRequestFactory
    from rest_framework import status
except ImportError:  # pragma: no cover - skip tests if environment missing dependencies
    import pytest as _pytest
    _pytest.skip("Required packages for integration tests are not available", allow_module_level=True)


@pytest.mark.parametrize("created, expect_slug_generated", [
    (True, True),
    (False, False),
])
def test_add_slug_to_article_if_not_exists_creates_slug_and_saves(monkeypatch, created, expect_slug_generated):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # create a dummy article-like object that mimics minimal model interface
    class DummyArticle:
        def __init__(self, title, slug=None):
            self.title = title
            self.slug = slug
            self._saved_called = 0

        def save(self, *args, **kwargs):
            self._saved_called += 1

    dummy = DummyArticle(title="Hello World", slug=None)

    # Act
    # call the signal handler as Django would during post_save
    article_signals.add_slug_to_article_if_not_exists(sender=None, instance=dummy, created=created)

    # Assert
    if expect_slug_generated:
        # if created=True we expect a slug was added and save called once
        assert isinstance(dummy.slug, str) and dummy.slug != ""
        assert dummy._saved_called == 1
    else:
        # if created=False handler should not modify or save
        assert dummy.slug is None
        assert dummy._saved_called == 0


def test_tag_str_and_taglist_view_returns_tag_names(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Test Tag.__str__ with a simple object that exposes .name
    fake_tag_obj = type("SimpleTag", (), {"name": "python"})()
    # Tag.__str__ is expected to access .name
    assert article_models.Tag.__str__(fake_tag_obj) == "python"

    # Now arrange the TagListAPIView to use a mocked Tag.objects chain that returns names
    expected_names = ["python", "django"]

    class DummyQueryset:
        def __init__(self, names):
            self._names = names

        def distinct(self):
            return self

        def values_list(self, *args, **kwargs):
            # mimic values_list(..., flat=True) returning iterable of names
            return self._names

    class DummyManager:
        def __init__(self, names):
            self._names = names

        def all(self):
            return DummyQueryset(self._names)

        def distinct(self):
            return DummyQueryset(self._names)

        def values_list(self, *a, **kw):
            return self._names

    # Replace Tag.objects with our dummy manager for the duration of the test
    monkeypatch.setattr(article_models.Tag, "objects", DummyManager(expected_names), raising=False)

    # Act
    factory = APIRequestFactory()
    request = factory.get("/api/tags")
    view = TagListAPIView()
    response = view.get(request)

    # Assert
    assert response.status_code == status.HTTP_200_OK
    # The TagListAPIView is expected to return {"tags": [ ... ]}
    assert isinstance(response.data, dict)
    assert response.data.get("tags") == expected_names


@pytest.mark.parametrize("raises_error", [False, True])
def test_tagrelatedfield_to_internal_value_and_to_representation(monkeypatch, raises_error):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    field = article_relations.TagRelatedField()

    # Prepare a fake Tag instance to be returned by get_or_create
    fake_tag = type("FakeTag", (), {"name": "python"})()

    # Helper functions for manager behavior
    def fake_get_or_create(name):
        # mimic Django's Tag.objects.get_or_create signature: (obj, created_bool)
        return (fake_tag, True)

    def fake_get_or_create_raises(name):
        raise RuntimeError("db error")

    # Monkeypatch the Tag.objects.get_or_create to our fake implementations
    if not raises_error:
        monkeypatch.setattr(article_models.Tag, "objects", mock.Mock(get_or_create=lambda self_name=None: fake_get_or_create(self_name)), raising=False)
    else:
        monkeypatch.setattr(article_models.Tag, "objects", mock.Mock(get_or_create=lambda self_name=None: fake_get_or_create_raises(self_name)), raising=False)

    # Act / Assert
    if not raises_error:
        # normal case: string input should be converted to tag instance
        result = field.to_internal_value("python")
        assert result is fake_tag

        # to_representation should convert tag instance back to its name
        rep = field.to_representation(fake_tag)
        assert isinstance(rep, str)
        assert rep == "python"
    else:
        # error path: underlying get_or_create raises -> propagate
        with pytest.raises(RuntimeError):
            field.to_internal_value("python")
