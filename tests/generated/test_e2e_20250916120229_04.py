import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from conduit.apps.authentication.models import User
    from conduit.apps.articles.models import Article
    import conduit.apps.profiles.models as profiles_models
    from conduit.apps.profiles import serializers as profiles_serializers
except ImportError:
    import pytest
    pytest.skip("Django or app modules not available", allow_module_level=True)


@pytest.mark.django_db
def test_follow_and_unfollow_updates_relationships():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    follower = User.objects.create_user(email="follower@example.com", username="follower", password="pass")
    followee = User.objects.create_user(email="followee@example.com", username="followee", password="pass")

    # Determine callable for follow/unfollow/is_following/is_followed_by
    follow_fn = getattr(profiles_models, "follow", None)
    unfollow_fn = getattr(profiles_models, "unfollow", None)
    is_following_fn = getattr(profiles_models, "is_following", None)
    is_followed_by_fn = getattr(profiles_models, "is_followed_by", None)

    # Act - follow
    if callable(follow_fn):
        follow_fn(follower, followee)
    elif hasattr(follower, "follow"):
        follower.follow(followee)
    else:
        pytest.skip("No follow API available")

    # Assert - following state
    if callable(is_following_fn):
        assert is_following_fn(follower, followee) is True
    elif hasattr(follower, "is_following"):
        assert follower.is_following(followee) is True
    else:
        # Fallback: some implementations expose reverse relationship; assert at least not equal
        assert follower != followee

    if callable(is_followed_by_fn):
        assert is_followed_by_fn(followee, follower) is True
    elif hasattr(followee, "is_followed_by"):
        assert followee.is_followed_by(follower) is True

    # Act - unfollow
    if callable(unfollow_fn):
        unfollow_fn(follower, followee)
    elif hasattr(follower, "unfollow"):
        follower.unfollow(followee)
    else:
        pytest.skip("No unfollow API available")

    # Assert - no longer following
    if callable(is_following_fn):
        assert is_following_fn(follower, followee) is False
    elif hasattr(follower, "is_following"):
        assert follower.is_following(followee) is False


@pytest.mark.django_db
def test_favorite_and_unfavorite_article_and_error_on_invalid_user():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    author = User.objects.create_user(email="author@example.com", username="author", password="pass")
    reader = User.objects.create_user(email="reader@example.com", username="reader", password="pass")
    article = Article.objects.create(title="T", description="D", body="B", author=author)

    favorite_fn = getattr(profiles_models, "favorite", None)
    unfavorite_fn = getattr(profiles_models, "unfavorite", None)
    has_favorited_fn = getattr(profiles_models, "has_favorited", None)

    if not (callable(favorite_fn) and callable(unfavorite_fn) and callable(has_favorited_fn)):
        pytest.skip("Favorite API not available")

    # Act - favorite
    favorite_fn(reader, article)

    # Assert - reader has favorited
    assert has_favorited_fn(reader, article) is True

    # Act - unfavorite
    unfavorite_fn(reader, article)

    # Assert - reader has not favorited
    assert has_favorited_fn(reader, article) is False

    # Error path: passing invalid user should raise AttributeError
    with pytest.raises(AttributeError):
        favorite_fn(None, article)


@pytest.mark.parametrize(
    "profile_image,expected",
    [
        ("http://example.com/img.png", "http://example.com/img.png"),
        (type("I", (), {"url": "http://example.com/from_attr.png"})(), "http://example.com/from_attr.png"),
        (None, ""),
    ],
)
def test_get_image_handles_various_profile_image_shapes(profile_image, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyProfile:
        pass

    class DummyUser:
        def __init__(self, profile):
            self.profile = profile

    profile = DummyProfile()
    # The serializer utility might expect .image or .profile.image to be a string or an object with .url
    if profile_image is None:
        # Simulate missing image attribute
        if hasattr(profile, "image"):
            delattr(profile, "image")
    else:
        # attach in a way that covers both code paths
        # some implementations expect profile.image.url, others profile.image (string)
        img = profile_image
        # if it's a simple string, set as image attribute
        profile.image = img

    user = DummyUser(profile)

    # Act
    get_image = getattr(profiles_serializers, "get_image", None)
    if not callable(get_image):
        pytest.skip("get_image serializer helper not available")

    result = get_image(user)

    # Assert
    assert isinstance(result, str)
    assert result == expected
