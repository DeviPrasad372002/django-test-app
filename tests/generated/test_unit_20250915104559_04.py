import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    import pytest
    import sys
    import types
    import importlib
    from unittest import mock
    # Attempt to import target modules; if anything fails, skip the whole module.
    relations_module = importlib.import_module("conduit.apps.articles.relations")
    articles_init_module = importlib.import_module("conduit.apps.articles.__init__")
    mig_module = importlib.import_module("conduit.apps.articles.migrations.0001_initial")
    models_module = importlib.import_module("conduit.apps.articles.models")
    TagRelatedField = getattr(relations_module, "TagRelatedField")
    Tag = getattr(models_module, "Tag")
    # Optionally import DRF ValidationError for negative tests (may raise ImportError -> skip)
    from rest_framework.serializers import ValidationError
except Exception:
    import pytest
    pytest.skip("Required project or third-party modules not available for tests", allow_module_level=True)


def test_articles_appconfig_ready_imports_signals_and_returns_none(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: inject fake signals modules to sys.modules so imports inside ready() are predictable
    fake_articles_signals = types.ModuleType("conduit.apps.articles.signals")
    fake_auth_signals = types.ModuleType("conduit.apps.authentication.signals")
    fake_articles_signals.IMPORTED_BY_READY = False
    fake_auth_signals.IMPORTED_BY_READY = False
    monkeypatch.setitem(sys.modules, "conduit.apps.articles.signals", fake_articles_signals)
    monkeypatch.setitem(sys.modules, "conduit.apps.authentication.signals", fake_auth_signals)

    app_config_cls = getattr(articles_init_module, "ArticlesAppConfig", None)
    assert app_config_cls is not None and callable(app_config_cls), "Expected ArticlesAppConfig to be present and callable"

    # Act: call ready() â€” should not raise and typically returns None
    result = app_config_cls().ready()

    # Assert: ensure function completed and didn't return any value (conventionally None)
    assert result is None
    # Also assert our injected modules remain available, implying imports inside ready() used them
    assert sys.modules.get("conduit.apps.articles.signals") is fake_articles_signals
    assert sys.modules.get("conduit.apps.authentication.signals") is fake_auth_signals


def test_migration_has_dependencies_and_operations():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: obtain Migration class from migration module
    Migration = getattr(mig_module, "Migration", None)
    assert Migration is not None and isinstance(Migration, type), "Migration class must exist"

    # Act: instantiate Migration (Django migrations usually define class attributes; instantiation should succeed)
    migration_instance = Migration()

    # Assert: Migration should declare dependencies and operations attributes as iterable (list or tuple)
    assert hasattr(migration_instance, "dependencies"), "Migration should have 'dependencies' attribute"
    assert isinstance(migration_instance.dependencies, (list, tuple)), "dependencies should be a list or tuple"
    assert hasattr(migration_instance, "operations"), "Migration should have 'operations' attribute"
    assert isinstance(migration_instance.operations, (list, tuple)), "operations should be a list or tuple"


@pytest.mark.parametrize("tag_name", ["python", "", "tag-with-hyphen"])
def test_tagrelatedfield_to_representation_and_to_internal_value_success(monkeypatch, tag_name):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake Tag object and manager to simulate Tag.objects.get_or_create behavior
    class FakeTag:
        def __init__(self, name):
            self.name = name

        def __repr__(self):
            return f"<FakeTag {self.name!r}>"

    class FakeManager:
        def __init__(self):
            self.called_with = None

        def get_or_create(self, name):
            # Simulate successful get_or_create returning the FakeTag instance
            self.called_with = name
            return (FakeTag(name), True)

    fake_manager = FakeManager()
    FakeTag.objects = fake_manager

    # Monkeypatch the relations module's Tag reference so TagRelatedField will use our FakeTag
    monkeypatch.setattr(relations_module, "Tag", FakeTag, raising=False)

    # Act
    field = TagRelatedField()
    # to_representation typically expects a Tag-like object
    rep = field.to_representation(FakeTag(tag_name))
    internal = field.to_internal_value(tag_name)

    # Assert: representation should be the tag name (string), and internal should be a FakeTag instance with same name
    assert isinstance(rep, str), "to_representation must return a string"
    assert rep == tag_name
    assert isinstance(internal, FakeTag), "to_internal_value must return a Tag-like instance"
    assert getattr(internal, "name") == tag_name
    assert fake_manager.called_with == tag_name


def test_tagrelatedfield_to_internal_value_propagates_validation_error_on_manager_failure(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: Create a manager that raises an error to simulate invalid input or DB failure
    class BadManager:
        def get_or_create(self, name):
            raise ValueError("simulated manager error")

    class FakeTag:
        pass

    FakeTag.objects = BadManager()
    monkeypatch.setattr(relations_module, "Tag", FakeTag, raising=False)

    field = TagRelatedField()

    # Act & Assert: ensure that a DRF ValidationError is raised for invalid tag input/DB errors
    with pytest.raises(ValidationError):
        _ = field.to_internal_value("invalid-tag!")
