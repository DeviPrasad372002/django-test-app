import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest
try:
    import json
    from unittest.mock import Mock
    import conduit.apps.authentication.renderers as renderers_module
    import conduit.apps.authentication.serializers as serializers_module
    import conduit.apps.authentication.backends as backends_module
    import conduit.apps.authentication.models as auth_models
except ImportError as e:
    pytest.skip(f"Skipping tests due to ImportError: {e}", allow_module_level=True)


def test_userjsonrenderer_renders_user_key_and_json_bytes():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = renderers_module.UserJSONRenderer()
    payload = {"user": {"username": "alice", "email": "alice@example.com"}}

    # Act
    output = renderer.render(payload)

    # Assert
    assert isinstance(output, (bytes, bytearray)), "Renderer should return bytes"
    text = output.decode("utf-8")
    parsed = json.loads(text)
    assert "user" in parsed, "Rendered JSON should contain 'user' key"
    assert parsed["user"]["username"] == "alice"
    assert parsed["user"]["email"] == "alice@example.com"


@pytest.mark.parametrize(
    "input_data,expected_valid",
    [
        ({"username": "bob", "email": "bob@example.com"}, False),  # missing password -> invalid
        ({"username": "charlie", "email": "charlie@example.com", "password": "secret"}, True),  # valid
    ],
)
def test_registration_serializer_validates_and_produces_validated_data(input_data, expected_valid):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    serializer = serializers_module.RegistrationSerializer(data=input_data)

    # Act
    is_valid = serializer.is_valid()

    # Assert
    assert is_valid is expected_valid
    if not expected_valid:
        # Expect an error mentioning password when it's missing
        assert serializer.errors, "Expected validation errors for missing fields"
        assert "password" in json.dumps(serializer.errors).lower() or any(
            "password" in k.lower() for k in serializer.errors.keys()
        )
    else:
        # On valid input, validated_data should contain username and email
        assert serializer.validated_data.get("username") == input_data["username"]
        assert serializer.validated_data.get("email") == input_data["email"]


def test_login_serializer_invalid_credentials_causes_error(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: force authenticate used by the serializer module to return None (invalid credentials)
    monkeypatch.setattr(serializers_module, "authenticate", lambda **kwargs: None)
    data = {"email": "noone@example.com", "password": "wrong"}
    serializer = serializers_module.LoginSerializer(data=data)

    # Act
    is_valid = serializer.is_valid()

    # Assert
    assert not is_valid
    assert serializer.errors, "Expected errors for invalid credentials"
    # Typically, non_field_errors or a message about credentials should appear
    errors_text = json.dumps(serializer.errors).lower()
    assert "credentials" in errors_text or "non_field_errors" in errors_text or "invalid" in errors_text


def test_jwtauthentication_authenticates_with_valid_token(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    jwt_payload = {"user_id": 42}
    fake_user = Mock()

    # Replace the jwt module used in backends_module with a fake that returns our payload
    fake_jwt_module = Mock()
    # backend likely calls jwt.decode(token, settings.SECRET_KEY, algorithms=[...])
    fake_jwt_module.decode = lambda token, key, algorithms=None: jwt_payload
    monkeypatch.setattr(backends_module, "jwt", fake_jwt_module)

    # Ensure SECRET_KEY access won't fail (backend may import django.conf.settings)
    try:
        from django.conf import settings as dj_settings
        monkeypatch.setattr(dj_settings, "SECRET_KEY", "test-secret", raising=False)
    except Exception:
        # If Django settings not available, backend code may not require it in our patched decode
        pass

    # Patch the User.objects.get used by the authentication backend to return our fake user
    # Some implementations use auth_models.User.objects.get(pk=...) or get(id=...), we provide a generic get
    fake_manager = Mock()
    fake_manager.get = Mock(return_value=fake_user)
    monkeypatch.setattr(auth_models.User, "objects", fake_manager, raising=False)

    auth = backends_module.JWTAuthentication()

    # Act
    result = auth._authenticate_credentials("sometoken")

    # Assert
    assert result is fake_user, "Expected the authentication backend to return the user fetched from the manager"
