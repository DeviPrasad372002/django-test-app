import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import json
    import random
    import pytest

    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.articles.renderers import ArticleJSONRenderer
    from conduit.apps.authentication.renderers import UserJSONRenderer
except ImportError:
    import pytest  # pragma: no cover
    pytest.skip("Required modules for tests are not available", allow_module_level=True)


import_types = (str, bytes)


@pytest.mark.parametrize("length", [1, 5, 10])
def test_generate_random_string_returns_expected_length_and_type(monkeypatch, length):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: make random.choice deterministic
    monkeypatch.setattr(random, "choice", lambda seq: "X")
    # Act
    result = generate_random_string(length)
    # Assert
    assert isinstance(result, str)
    assert len(result) == length
    assert result == "X" * length


@pytest.mark.parametrize(
    "input_obj, expected_key",
    [
        ({"title": "Hello", "body": "World"}, "article"),
        ([{"title": "A"}, {"title": "B"}], "articles"),
    ],
)
def test_article_json_renderer_wraps_payload_correctly(input_obj, expected_key):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()
    # Act
    rendered = renderer.render(input_obj)
    # Assert: type and JSON structure
    assert isinstance(rendered, (bytes,))
    parsed = json.loads(rendered.decode("utf-8"))
    assert expected_key in parsed
    # When it's a single dict, the renderer should embed it directly under 'article'
    if expected_key == "article":
        assert parsed["article"] == input_obj
    else:
        assert parsed["articles"] == input_obj


def test_article_json_renderer_raises_on_non_serializable_input():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()
    non_serializable = {"bad": {1, 2, 3}}  # sets are not JSON serializable
    # Act/Assert
    with pytest.raises(TypeError):
        _ = renderer.render(non_serializable)


def test_user_json_renderer_produces_user_wrapper_and_bytes():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()
    user_payload = {"email": "x@example.com", "username": "xuser"}
    # Act
    rendered = renderer.render(user_payload)
    # Assert
    assert isinstance(rendered, (bytes,))
    parsed = json.loads(rendered.decode("utf-8"))
    assert "user" in parsed
    assert parsed["user"] == user_payload
