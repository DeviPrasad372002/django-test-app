import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest

try:
    import json
    import jwt
    from unittest.mock import Mock
    from types import SimpleNamespace

    from conduit.apps.authentication.models import UserManager, User
    from conduit.apps.authentication.backends import JWTAuthentication
    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.authentication.serializers import UserSerializer
    from rest_framework.exceptions import AuthenticationFailed
except ImportError:
    pytest.skip("Third-party or project imports not available, skipping integration tests", allow_module_level=True)


@pytest.mark.parametrize(
    "case, email, username, password, expect_error",
    [
        ("valid", "alice@example.com", "alice", "s3cret", False),
        ("missing_email", "", "noemail", "pw", True),
    ],
)
def test_user_manager_create_user_success_and_error(case, email, username, password, expect_error, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake model to avoid interacting with a real database.
    saved = {"called": False}

    class FakeModel:
        def __init__(self, email=None, username=None):
            self.email = email
            self.username = username
            self._password_set = None

        def set_password(self, raw):
            # emulate Django's set_password hashing behavior by recording that it was called
            self._password_set = f"hashed:{raw}"

        def save(self):
            saved["called"] = True

    manager = UserManager()
    # Replace the manager.model with our fake model class
    manager.model = FakeModel

    # Act / Assert
    if expect_error:
        with pytest.raises(ValueError):
            # Act: missing email should raise
            manager.create_user(email=email, username=username, password=password)
    else:
        # Act: create user normally
        created = manager.create_user(email=email, username=username, password=password)

        # Assert
        assert isinstance(created, FakeModel)
        assert created.email == email
        assert created.username == username
        # verify that set_password was called (our fake records hashed:...)
        assert getattr(created, "_password_set", None) == f"hashed:{password}"
        # verify save was called
        assert saved["called"] is True


@pytest.mark.parametrize(
    "scenario, decode_raises, expected_exception",
    [
        ("valid_token", False, None),
        ("invalid_token_decode", True, AuthenticationFailed),
    ],
)
def test_jwtauthentication_authenticate_credentials_success_and_decode_error(scenario, decode_raises, expected_exception, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()

    # Prepare a fake user object to be returned by the fake User manager
    fake_user = SimpleNamespace(pk=123, id=123, email="bob@example.com", is_active=True)

    class FakeObjects:
        @staticmethod
        def get(pk):
            if pk == 123:
                return fake_user
            raise Exception("DoesNotExist")

    # Create a FakeUser type that mimics the model used by the backend module.
    FakeUserModel = SimpleNamespace
    # Monkeypatch the User model referenced in the backends module to use our fake objects manager
    monkeypatch.setattr(
        "conduit.apps.authentication.backends.User",
        SimpleNamespace(objects=FakeObjects, DoesNotExist=Exception),
        raising=True,
    )

    # Monkeypatch jwt.decode behavior
    def decode_ok(token, key, algorithms=None):
        return {"id": 123}

    def decode_error(token, key, algorithms=None):
        raise jwt.DecodeError("invalid token")

    if decode_raises:
        monkeypatch.setattr(jwt, "decode", decode_error)
    else:
        monkeypatch.setattr(jwt, "decode", decode_ok)

    token_string = "Bearer sometokenstring"

    # Act / Assert
    if expected_exception is not None:
        with pytest.raises(expected_exception):
            # Act: should raise when decode fails
            auth._authenticate_credentials(token_string)
    else:
        # Act: should return the fake user when decode succeeds
        user = auth._authenticate_credentials(token_string)
        # Assert
        assert user is fake_user
        assert getattr(user, "email") == "bob@example.com"
        assert getattr(user, "is_active") is True


def test_user_serializer_and_user_json_renderer_integration(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake user instance that mimics the attributes the serializer expects.
    class FakeUser:
        def __init__(self, email, username, bio=None, image=None, token_value="tok.123"):
            self.email = email
            self.username = username
            self.bio = bio
            self.image = image
            # token may be implemented as a property on real model; emulate here
            self._token_value = token_value

        @property
        def token(self):
            return self._token_value

    fake = FakeUser(email="carol@example.com", username="carol", bio="bio text", image=None, token_value="jwt.token.value")

    # Act
    serializer = UserSerializer(instance=fake)
    serialized = serializer.data  # should be a dict-like mapping of user fields

    renderer = UserJSONRenderer()
    rendered_bytes = renderer.render(serialized, renderer_context={})

    # Assert
    assert isinstance(serialized, dict)
    assert serialized["email"] == "carol@example.com"
    # serialized should include token value
    assert "token" in serialized and serialized["token"] == "jwt.token.value"

    # rendered output should be JSON bytes; decode and assert content
    assert isinstance(rendered_bytes, (bytes, bytearray))
    decoded = json.loads(rendered_bytes.decode("utf-8"))
    # The renderer wraps the payload under a 'user' key per convention
    assert "user" in decoded
    assert decoded["user"]["email"] == "carol@example.com"
    assert decoded["user"]["token"] == "jwt.token.value"
