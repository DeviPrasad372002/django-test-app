import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from unittest.mock import Mock
    import jwt
    from rest_framework import exceptions
    from conduit.apps.authentication.backends import JWTAuthentication
    from conduit.apps.authentication import backends as auth_backends_module
    from conduit.apps.authentication.models import User
    from conduit.apps.articles.views import ArticleViewSet
except ImportError:
    import pytest
    pytest.skip("Skipping integration tests because required third-party modules are not available", allow_module_level=True)


@pytest.mark.parametrize(
    "auth_header, expected",
    [
        (None, None),  # no header should return None
        ("Bearer sometoken", None),  # wrong prefix should return None
        ("Token", None),  # malformed header should return None
    ],
)
def test_integration_02_jwt_authenticate_header_variants(monkeypatch, auth_header, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()
    request = Mock()
    # simulate Django request.META style storage via headers attribute used by DRF auth
    if auth_header is None:
        request.META = {}
    else:
        # DRF's JWTAuthentication typically reads HTTP_AUTHORIZATION from request.META
        request.META = {"HTTP_AUTHORIZATION": auth_header}
    # Ensure internal credential method is not invoked (would raise if called)
    monkeypatch.setattr(auth, "_authenticate_credentials", lambda token: (_ for _ in ()).throw(AssertionError("Should not be called")))
    # Act
    result = auth.authenticate(request)
    # Assert
    assert result is expected


def test_integration_03_jwt_authenticate_raises_on_internal_failure(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()
    # Provide a header that looks valid so authenticate attempts to call internal method
    request = Mock()
    request.META = {"HTTP_AUTHORIZATION": "Token badtoken"}
    # Simulate internal failure
    monkeypatch.setattr(
        auth,
        "_authenticate_credentials",
        lambda token: (_ for _ in ()).throw(exceptions.AuthenticationFailed("invalid token")),
    )
    # Act / Assert
    with pytest.raises(exceptions.AuthenticationFailed):
        auth.authenticate(request)


@pytest.mark.parametrize(
    "decoded_payload, user_exists, is_active, expect_exception",
    [
        ({"user_id": 1}, False, False, True),  # user missing -> exception
        ({"user_id": 1}, True, False, True),  # inactive user -> exception
        ({"user_id": 1}, True, True, False),  # active user -> success
    ],
)
def test_integration_04__authenticate_credentials_user_not_found_and_success(
    # Arrange-Act-Assert: generated by ai-testgen
    monkeypatch, decoded_payload, user_exists, is_active, expect_exception
):
    # Arrange
    auth = JWTAuthentication()
    test_token = "signed.jwt.token"
    # Monkeypatch jwt.decode to return our payload for the provided token
    def fake_jwt_decode(token, key='', algorithms=None):
        assert token == test_token
        return decoded_payload

    monkeypatch.setattr(jwt, "decode", fake_jwt_decode)

    # Prepare a fake user or raise DoesNotExist
    fake_user = Mock()
    fake_user.is_active = is_active

    # Replace User.objects.get with a function that inspects kwargs and either returns user or raises
    class DummyDoesNotExist(Exception):
        pass

    # Use the actual model DoesNotExist if available for clearer expectations
    DoesNotExist = getattr(User, "DoesNotExist", DummyDoesNotExist)

    def fake_get(**kwargs):
        # Accept any lookup that includes the id value from payload
        if user_exists:
            return fake_user
        raise DoesNotExist()

    # Monkeypatch the manager
    monkeypatch.setattr(User, "objects", Mock(get=fake_get))

    # Act / Assert
    if expect_exception:
        with pytest.raises(exceptions.AuthenticationFailed):
            auth._authenticate_credentials(test_token)
    else:
        result = auth._authenticate_credentials(test_token)
        # Assert the successful return is a tuple (user, token)
        assert isinstance(result, tuple)
        assert result[0] is fake_user
        assert result[1] == test_token


@pytest.mark.parametrize(
    "query_params, expected_filter_calls",
    [
        ({}, []),  # no filters => no filter calls
        ({"author": "alice"}, [("filter", (), {"author__username": "alice"})]),
        ({"tag": "python"}, [("filter", (), {"tags__name": "python"})]),
        (
            {"author": "alice", "tag": "python"},
            [
                ("filter", (), {"author__username": "alice"}),
                ("filter", (), {"tags__name": "python"}),
            ],
        ),
        # favorited param is an edge case: view typically attempts to filter based on favorites relationship.
        # We assert that a filter call is made when favorited is present; exact kwargs may vary by implementation,
        # so we only assert that filter was called at least once.
        ({"favorited": "bob"}, [("filter", (), {})]),
    ],
)
def test_integration_05_filter_queryset_calls_queryset_filters(monkeypatch, query_params, expected_filter_calls):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    view = ArticleViewSet()
    request = Mock()
    request.query_params = query_params
    view.request = request

    # Create a mock queryset whose .filter method returns itself so chained calls work
    mock_qs = Mock(name="QuerySet")
    # Make filter return the mock_qs so repeated filter calls are possible
    mock_qs.filter.return_value = mock_qs

    # Act
    result_qs = view.filter_queryset(mock_qs)

    # Assert: result should be the mock_qs (since our fake filters return same)
    assert result_qs is mock_qs

    # Now assert expected filter calls. For the generic favorited case we only assert that filter was called.
    if "favorited" in query_params and expected_filter_calls and expected_filter_calls[0][1] == ():
        # We expect at least one filter call but kwargs may vary; assert call_count >= 1
        assert mock_qs.filter.call_count >= 1
    else:
        # Build the expected call objects and compare
        expected_calls = []
        for name, args, kwargs in expected_filter_calls:
            # All expected entries are filter calls
            expected_calls.append(((args), kwargs))
        # Extract actual calls as tuples of (args, kwargs)
        actual_calls = [(call.args, call.kwargs) for call in mock_qs.filter.call_args_list]
        # If we expected no calls, actual_calls should be empty
        if not expected_calls:
            assert actual_calls == []
        else:
            # The view might call filters in sequence; ensure expected calls appear in the same order
            # We match by kwargs only since args are typically empty
            actual_kwargs_list = [ck for (_, ck) in actual_calls]
            expected_kwargs_list = [kw for (_, kw) in expected_calls]
            assert actual_kwargs_list == expected_kwargs_list
