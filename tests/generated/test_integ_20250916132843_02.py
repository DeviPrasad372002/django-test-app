import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest
import json
from unittest import mock

try:
    from target.conduit.apps.articles.renderers import CommentJSONRenderer
    from target.conduit.apps.authentication.renderers import UserJSONRenderer
    import target.conduit.apps.authentication.models as auth_models
    import target.conduit.apps.authentication.backends as auth_backends
    import jwt
    from rest_framework.exceptions import AuthenticationFailed
except ImportError:
    pytest.skip("Required third-party or target modules not available", allow_module_level=True)


def test_comment_json_renderer_wraps_comment_dict():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = CommentJSONRenderer()
    input_data = {
        "id": 123,
        "body": "This is a comment",
        "createdAt": "2020-01-01T00:00:00Z",
        "updatedAt": "2020-01-01T00:00:00Z",
        "author": {"username": "alice", "bio": None, "image": None}
    }

    # Act
    rendered = renderer.render({"comment": input_data})

    # Assert
    assert isinstance(rendered, (bytes, bytearray))
    decoded = json.loads(rendered.decode("utf-8"))
    assert "comment" in decoded
    assert isinstance(decoded["comment"], dict)
    # concrete checks for fields and types
    assert decoded["comment"]["id"] == 123
    assert decoded["comment"]["body"] == "This is a comment"
    assert decoded["comment"]["author"]["username"] == "alice"


def test_user_json_renderer_wraps_user_with_token_and_profile():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()
    user_payload = {
        "email": "bob@example.com",
        "token": "sometoken123",
        "username": "bob",
        "bio": "bio text",
        "image": None
    }

    # Act
    rendered = renderer.render({"user": user_payload})

    # Assert
    assert isinstance(rendered, (bytes, bytearray))
    decoded = json.loads(rendered.decode("utf-8"))
    assert "user" in decoded
    user = decoded["user"]
    assert user["email"] == "bob@example.com"
    assert user["token"] == "sometoken123"
    assert user["username"] == "bob"
    assert user["bio"] == "bio text"
    assert user["image"] is None


def test__generate_jwt_token_uses_jwt_encode(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake user-like object expected by the function (uses .pk or .id)
    fake_user = type("U", (), {"pk": 99, "id": 99})()
    captured = {}

    def fake_encode(payload, secret, algorithm="HS256"):
        # capture payload for assertions and return a predictable byte string
        captured["payload"] = payload
        captured["secret"] = secret
        captured["algorithm"] = algorithm
        return b"FAKE.JWT.TOKEN"

    # Ensure the module under test uses our fake encode
    monkeypatch.setattr(auth_models.jwt, "encode", fake_encode)

    # Act
    token = auth_models._generate_jwt_token(fake_user)

    # Assert
    # token may be bytes or str depending on implementation; normalize to str for assertion
    assert isinstance(token, (bytes, str))
    if isinstance(token, bytes):
        token_str = token.decode("utf-8")
    else:
        token_str = token
    assert token_str == "FAKE.JWT.TOKEN"
    # verify payload contains an identifier for the user and exp claim-ish
    assert isinstance(captured.get("payload"), dict)
    assert 99 in (captured["payload"].get("id"), captured["payload"].get("user_id"), captured["payload"].get("pk"), captured["payload"].get("user"))
    assert captured["algorithm"] == "HS256"


def test__authenticate_credentials_invalid_token_raises(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = auth_backends.JWTAuthentication()

    # Make jwt.decode raise a DecodeError to simulate an invalid token
    def raise_decode(*args, **kwargs):
        raise jwt.DecodeError("Invalid token")

    monkeypatch.setattr(auth_backends.jwt, "decode", raise_decode)

    # Act / Assert: should raise AuthenticationFailed on invalid token
    with pytest.raises(AuthenticationFailed):
        auth._authenticate_credentials(None, "invalid.token.value")
