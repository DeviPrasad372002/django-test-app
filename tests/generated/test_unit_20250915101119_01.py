import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest
from types import SimpleNamespace

try:
    from conduit.apps.articles.signals import add_slug_to_article_if_not_exists
    from conduit.apps.articles.serializers import ArticleSerializer
    from conduit.apps.articles.relations import TagRelatedField
    from django.utils.text import slugify
    import datetime
except ImportError:
    pytest.skip("Skipping tests - project modules or Django not available", allow_module_level=True)


class DummyArticle:
    def __init__(self, title=None, slug=None, favorites=None):
        self.title = title
        self.slug = slug
        # favorites can be any object with a count() method or a simple list
        self.favorites = favorites


class DummyTag:
    def __init__(self, name):
        self.name = name


@pytest.mark.parametrize(
    "initial_slug, rand_value, expected_slug",
    [
        (None, "XYZ123", f"{slugify('My Title')}-XYZ123"),  # normal: create new slug
        ("existing-slug", "SHOULD_NOT_BE_USED", "existing-slug"),  # edge: keep existing
    ],
)
def test_add_slug_to_article_if_not_exists_behaviour(monkeypatch, initial_slug, rand_value, expected_slug):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    dummy = DummyArticle(title="My Title", slug=initial_slug)

    # ensure the signal will call our predictable random generator
    # patch the function in the module where the signal will call it
    try:
        import conduit.apps.articles.signals as signals_mod
    except Exception:
        pytest.skip("Could not import signals module for patching", allow_module_level=False)
    monkeypatch.setattr(signals_mod, "generate_random_string", lambda *args, **kwargs: rand_value)

    # Act
    add_slug_to_article_if_not_exists(sender=None, instance=dummy)

    # Assert
    assert isinstance(dummy.slug, (str, type(None)))
    assert dummy.slug == expected_slug


def test_article_serializer_get_created_and_updated_at_formats_iso():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    serializer = ArticleSerializer()
    created_dt = datetime.datetime(2020, 1, 2, 3, 4, 5)
    updated_dt = datetime.datetime(2021, 6, 7, 8, 9, 10)
    obj = SimpleNamespace(created_at=created_dt, updated_at=updated_dt)

    # Act
    created_out = serializer.get_created_at(obj)
    updated_out = serializer.get_updated_at(obj)

    # Assert: concrete isoformat strings
    assert isinstance(created_out, str)
    assert isinstance(updated_out, str)
    assert created_out == created_dt.isoformat()
    assert updated_out == updated_dt.isoformat()


def test_article_serializer_get_favorites_count_and_get_favorited(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    serializer = ArticleSerializer(context={"request": SimpleNamespace(user="user123")})

    # create a favorites-like object that provides count()
    class FavList(list):
        def count(self):
            return len(self)

    favs = FavList([1, 2, 3])
    # obj should implement has_favorited(user) for favorited check and provide favorites for count
    called = {"checked_with": None}

    class Obj:
        def __init__(self, favorites):
            self.favorites = favorites

        def has_favorited(self, user):
            called["checked_with"] = user
            return user == "user123"

    obj = Obj(favorites=favs)

    # Act
    fav_count = serializer.get_favorites_count(obj)
    favorited = serializer.get_favorited(obj)

    # Assert
    assert isinstance(fav_count, int)
    assert fav_count == 3  # concrete count expected
    assert favorited is True
    assert called["checked_with"] == "user123"


def test_tagrelatedfield_to_representation_and_internal_value_simple():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    field = TagRelatedField()
    tag = DummyTag(name="python")

    # Act
    rep = field.to_representation(tag)
    internal = field.to_internal_value("django")

    # Assert
    # to_representation should return the tag name for a tag-like object
    assert isinstance(rep, str)
    assert rep == "python"

    # to_internal_value should accept a string and return a suitable representation.
    # Many implementations return the string or a Tag-like object. We assert it's a string here.
    assert isinstance(internal, (str, dict, SimpleNamespace))
    # If it's a string, it should match the input; if it's an object/dict, it should contain the input.
    if isinstance(internal, str):
        assert internal == "django"
    elif isinstance(internal, dict):
        assert "name" in internal and internal["name"] == "django"
    else:
        # assume object with .name attribute
        assert getattr(internal, "name", None) == "django"
