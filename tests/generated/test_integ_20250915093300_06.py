import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest as _pytest
_pytest.skip('generator: banned private imports detected; skipping module', allow_module_level=True)

try:
    import pytest
    from unittest.mock import MagicMock
    import json
    from types import SimpleNamespace
    from unittest.mock import patch
except ImportError:
    import pytest as _pytest
    _pytest.skip("pytest or stdlib mocks not available", allow_module_level=True)

# Guard importing third-party or project modules; skip if unavailable.
try:
    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication import backends as auth_backends
    from conduit.apps.authentication import renderers as auth_renderers
    from conduit.apps.core import utils as core_utils
    import rest_framework.exceptions as rf_exceptions
except ImportError:
    pytest.skip("conduit app or rest_framework not available", allow_module_level=True)


def test__generate_jwt_token_calls_jwt_encode(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    captured = {}

    def fake_encode(payload, secret, algorithm='HS256'):
        # capture payload and return a predictable token
        captured['payload'] = payload
        captured['secret'] = secret
        captured['alg'] = algorithm
        return "signed_token_123"

    # Patch the jwt.encode used in the module under test
    monkeypatch.setattr(auth_models, "jwt", SimpleNamespace(encode=fake_encode), raising=False)

    # Create a minimal user-like object expected by the function
    user_like = SimpleNamespace(id=7)

    # Act
    token = auth_models._generate_jwt_token(user_like)

    # Assert
    assert isinstance(token, str)
    assert token == "signed_token_123"
    # payload should contain user id
    assert isinstance(captured.get('payload'), dict)
    assert captured['payload'].get('id') == 7
    # a secret should be passed (string)
    assert isinstance(captured.get('secret'), str)
    assert captured.get('alg') == 'HS256'


@pytest.mark.parametrize("decode_side_effect, expected_exception, expected_user_id", [
    # success case: decode returns payload with id
    ({"return_value": {"id": 42}}, None, 42),
    # failure case: decoding raises an exception -> should raise AuthenticationFailed
    ({"side_effect": Exception("bad token")}, rf_exceptions.AuthenticationFailed, None),
])
def test_JWTAuthentication_authenticate_success_and_failure(monkeypatch, decode_side_effect, expected_exception, expected_user_id):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Prepare a fake request with an Authorization header
    fake_token = "abc.def.ghi"
    request = SimpleNamespace(META={"HTTP_AUTHORIZATION": f"Token {fake_token}"})

    # Patch jwt.decode in the backend module
    def fake_decode_success(token, secret, algorithms=None):
        return {"id": 42}

    if "return_value" in decode_side_effect:
        monkeypatch.setattr(auth_backends, "jwt", SimpleNamespace(decode=lambda token, secret, algorithms=None: {"id": 42}), raising=False)
    elif "side_effect" in decode_side_effect:
        def raise_bad(*args, **kwargs):
            raise decode_side_effect["side_effect"]
        monkeypatch.setattr(auth_backends, "jwt", SimpleNamespace(decode=raise_bad), raising=False)
    else:
        monkeypatch.setattr(auth_backends, "jwt", SimpleNamespace(decode=fake_decode_success), raising=False)

    # Prepare a fake User model with objects.get returning a user instance
    class FakeUser:
        def __init__(self, id):
            self.id = id

    class FakeManager:
        @staticmethod
        def get(**kwargs):
            # emulate ORM get by id
            if kwargs.get('pk') == 42 or kwargs.get('id') == 42:
                return FakeUser(42)
            raise Exception("not found")

    FakeUserModel = SimpleNamespace(objects=FakeManager)

    # Patch the User reference inside the backend module
    monkeypatch.setattr(auth_backends, "User", FakeUserModel, raising=False)

    auth = auth_backends.JWTAuthentication()

    # Act / Assert
    if expected_exception is not None:
        with pytest.raises(expected_exception):
            auth.authenticate(request)
    else:
        user, token = auth.authenticate(request)
        assert isinstance(user, FakeUser)
        assert user.id == expected_user_id
        # token should be the raw token string passed in header
        assert isinstance(token, str)
        assert token == fake_token


def test_UserJSONRenderer_renders_user_wrapper_json():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = auth_renderers.UserJSONRenderer()
    payload = {"user": {"email": "alice@example.com", "username": "alice", "token": "tkn"}}

    # Act
    rendered = renderer.render(payload, accepted_media_type="application/json", renderer_context={})

    # Assert
    # Result should be bytes or str depending on implementation; normalize to str then parse JSON
    assert rendered is not None
    if isinstance(rendered, bytes):
        rendered_str = rendered.decode('utf-8')
    else:
        rendered_str = str(rendered)
    parsed = json.loads(rendered_str)
    assert "user" in parsed
    assert parsed["user"]["email"] == "alice@example.com"
    assert parsed["user"]["username"] == "alice"
    assert parsed["user"]["token"] == "tkn"


@pytest.mark.parametrize("length", [1, 5, 16, 32])
def test_generate_random_string_various_lengths_and_characters(length):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange & Act
    result = core_utils.generate_random_string(length)

    # Assert
    assert isinstance(result, str)
    assert len(result) == length
    # Ensure characters are alphanumeric or from the expected alphabet (lowercase letters + digits)
    # It's enough to check that result contains only printable ascii letters/digits
    for ch in result:
        assert ch.isalnum() or ch in ("_", "-") or ch.isprintable() is True
