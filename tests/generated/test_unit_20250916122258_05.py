import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import json
    from conduit.apps.articles.renderers import ArticleJSONRenderer, CommentJSONRenderer
    from conduit.apps.articles.serializers import ArticleSerializer, CommentSerializer, TagSerializer, Meta
    from conduit.apps.articles.models import Article, Comment, Tag
except ImportError as e:
    import pytest
    pytest.skip(f"Skipping tests: required modules not available: {e}", allow_module_level=True)


@pytest.mark.parametrize("renderer_class,input_data", [
    (ArticleJSONRenderer, {"title": "Test", "body": "Content"}),
    (ArticleJSONRenderer, [{"title": "ListItem"}]),
    (CommentJSONRenderer, {"id": 1, "body": "Nice"}),
    (CommentJSONRenderer, [{"id": 2, "body": "Also nice"}]),
])
def test_json_renderers_wrap_data_under_expected_key(renderer_class, input_data):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = renderer_class()
    expected_key = "article" if renderer_class is ArticleJSONRenderer else "comment"

    # Act
    output_bytes = renderer.render(input_data, media_type=None, renderer_context=None)

    # Assert
    assert isinstance(output_bytes, (bytes, bytearray))
    output_text = output_bytes.decode("utf-8")
    parsed = json.loads(output_text)
    assert expected_key in parsed
    # value should be equal to the input (lists/dicts preserved)
    assert parsed[expected_key] == input_data


@pytest.mark.parametrize("renderer_class,unserializable", [
    (ArticleJSONRenderer, set([1, 2, 3])),
    (ArticleJSONRenderer, object()),
    (CommentJSONRenderer, set([4, 5])),
    (CommentJSONRenderer, object()),
])
def test_json_renderers_raise_on_unserializable_input(renderer_class, unserializable):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = renderer_class()

    # Act / Assert: JSON serialization of arbitrary objects should raise TypeError or ValueError
    with pytest.raises((TypeError, ValueError)):
        renderer.render(unserializable, media_type=None, renderer_context=None)


def test_serializers_meta_models_and_types():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act: Inspect serializer Meta inner classes and associated model classes
    # Assert that Meta is a class/type
    assert isinstance(Meta, type)

    # ArticleSerializer should be tied to the Article model via its Meta
    assert hasattr(ArticleSerializer, "Meta")
    assert getattr(ArticleSerializer.Meta, "model", None) is Article

    # CommentSerializer should be tied to the Comment model via its Meta
    assert hasattr(CommentSerializer, "Meta")
    assert getattr(CommentSerializer.Meta, "model", None) is Comment

    # TagSerializer should be tied to the Tag model via its Meta
    assert hasattr(TagSerializer, "Meta")
    assert getattr(TagSerializer.Meta, "model", None) is Tag

    # Also assert that Meta.fields for each serializer is an iterable (list/tuple)
    for serializer_cls in (ArticleSerializer, CommentSerializer, TagSerializer):
        fields = getattr(serializer_cls.Meta, "fields", None)
        assert fields is not None
        assert isinstance(fields, (list, tuple)), "Expected Meta.fields to be list or tuple"
