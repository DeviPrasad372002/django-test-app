import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import jwt
    from conduit.apps.authentication.models import User
    from conduit.apps.authentication.serializers import RegistrationSerializer
    import conduit.apps.authentication.signals as auth_signals
    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.core.exceptions import core_exception_handler
    from django.conf import settings
    from rest_framework.exceptions import NotFound, APIException, ValidationError
    from rest_framework.response import Response
except ImportError:
    import pytest
    pytest.skip("Required Django/project modules not available", allow_module_level=True)


def test_get_short_name_returns_first_name_or_falls_back_to_email():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    user_with_name = User()
    user_with_name.first_name = "Alice"
    user_with_name.email = "alice@example.com"

    user_no_name = User()
    user_no_name.first_name = ""
    user_no_name.email = "no_name@example.com"

    # Act
    short_with_name = user_with_name.get_short_name()
    short_no_name = user_no_name.get_short_name()

    # Assert
    assert isinstance(short_with_name, str)
    assert short_with_name == "Alice"
    assert isinstance(short_no_name, str)
    assert short_no_name == "no_name@example.com"


def test_generate_jwt_token_uses_jwt_encode_and_includes_user_id(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    user = User()
    # set a predictable primary key
    user.pk = 12345

    captured = {}

    def fake_encode(payload, secret, algorithm="HS256"):
        captured["payload"] = payload
        captured["secret"] = secret
        captured["algorithm"] = algorithm
        return "faketoken"

    monkeypatch.setattr(jwt, "encode", fake_encode)
    # Ensure SECRET_KEY is present
    monkeypatch.setattr(settings, "SECRET_KEY", "test-secret", raising=False)

    # Act
    token = user._generate_jwt_token()

    # Assert
    assert token == "faketoken"
    assert "payload" in captured
    assert isinstance(captured["payload"], dict)
    assert captured["payload"].get("user_id") == user.pk
    assert "exp" in captured["payload"]
    assert captured["secret"] == "test-secret"
    assert captured["algorithm"] == "HS256"


@pytest.mark.parametrize(
    "data,expect_valid,expected_error_field",
    [
        ({"email": "bob@example.com", "username": "bob", "password": "s3cret"}, True, None),
        ({"email": "no_password@example.com", "username": "nopass"}, False, "password"),
        ({}, False, "email"),
    ],
)
def test_registration_serializer_validate_and_is_valid_behaviour(data, expect_valid, expected_error_field):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    serializer = RegistrationSerializer(data=data)

    # Act
    valid = serializer.is_valid()

    # Assert
    assert valid is expect_valid
    if not expect_valid:
        assert isinstance(serializer.errors, dict)
        # Expect at least one key indicating missing/invalid field
        assert expected_error_field in serializer.errors


def test_create_related_profile_creates_profile_when_created_true(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    created_calls = []

    class DummyManager:
        def create(self, **kwargs):
            created_calls.append(kwargs)
            return kwargs

    class DummyProfile:
        objects = DummyManager()

    # Monkeypatch the Profile reference in the signals module
    monkeypatch.setattr(auth_signals, "Profile", DummyProfile, raising=False)

    user = User()
    user.pk = 10

    # Act: when created=True it should call Profile.objects.create
    auth_signals.create_related_profile(sender=User, instance=user, created=True)

    # Assert
    assert created_calls, "Profile.objects.create should have been called"
    assert created_calls[0].get("user") is user

    # Act: when created=False it should not call create again
    created_calls.clear()
    auth_signals.create_related_profile(sender=User, instance=user, created=False)

    # Assert
    assert created_calls == []


@pytest.mark.parametrize(
    "exc,expected_status",
    [
        (NotFound(detail="not found"), 404),
        (APIException(detail="server error"), 500),
    ],
)
def test_core_exception_handler_handles_known_exceptions(exc, expected_status):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    context = {}

    # Act
    response = core_exception_handler(exc, context)

    # Assert
    assert isinstance(response, Response)
    assert response.status_code == expected_status


def test_generate_random_string_various_lengths():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act / Assert for multiple lengths
    assert isinstance(generate_random_string(0), str)
    assert generate_random_string(0) == ""
    s1 = generate_random_string(1)
    assert isinstance(s1, str) and len(s1) == 1
    s10 = generate_random_string(10)
    assert isinstance(s10, str) and len(s10) == 10
