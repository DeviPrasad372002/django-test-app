import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import json
import pytest

try:
    from unittest.mock import Mock

    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.authentication.models import User
    import conduit.apps.authentication.models as auth_models
    from conduit.apps.authentication import AuthenticationAppConfig
except ImportError:
    pytest.skip("Required project or third-party imports are unavailable", allow_module_level=True)


def test_user_json_renderer_wraps_user_dict():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()
    payload = {"username": "alice", "email": "alice@example.com"}
    data = {"user": payload}

    # Act
    output = renderer.render(data, renderer_context={})

    # Assert
    assert isinstance(output, (bytes, str))
    # Ensure JSON structure wraps the payload under "user"
    decoded = output.decode("utf-8") if isinstance(output, bytes) else output
    parsed = json.loads(decoded)
    assert isinstance(parsed, dict)
    assert "user" in parsed
    assert parsed["user"] == payload


@pytest.mark.parametrize(
    "first_name,last_name,username,expected_full,expected_short",
    [
        ("Alice", "Smith", "alice", "Alice Smith", "alice"),
        ("", "", "bob", "", "bob"),  # edge case: no names provided
    ],
)
def test_user_get_full_and_short_name(first_name, last_name, username, expected_full, expected_short):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a User-like instance without involving the database
    user = User()
    # Populate attributes commonly expected by the methods under test
    user.first_name = first_name
    user.last_name = last_name
    user.username = username

    # Act
    full = user.get_full_name()
    short = user.get_short_name()

    # Assert
    assert isinstance(full, str)
    assert isinstance(short, str)
    assert full == expected_full
    assert short == expected_short


def test_authentication_app_config_ready_returns_none_and_name_is_set():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # AppConfig typically accepts (app_name, app_module) args; provide the name explicitly
    cfg = AuthenticationAppConfig("conduit.apps.authentication", "conduit.apps.authentication")

    # Act
    result = cfg.ready()  # should not raise and typically returns None

    # Assert
    assert result is None
    assert getattr(cfg, "name", None) == "conduit.apps.authentication"


def test_user_token_property_delegates_to_internal_generator(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    called = {"args": None}
    def fake_generator(u):
        called["args"] = u
        return "FAKE_TOKEN_123"

    # Replace the internal generator used by the User.token property
    monkeypatch.setattr(auth_models, "_generate_jwt_token", fake_generator, raising=False)

    # Create a bare User instance and ensure it has at least an id attribute
    user = User()
    # Some User implementations expect pk/id; set both to be safe
    setattr(user, "id", 77)
    setattr(user, "pk", 77)

    # Act
    token = getattr(user, "token")  # token implemented as property in many implementations

    # Assert
    assert isinstance(token, str)
    assert token == "FAKE_TOKEN_123"
    # Ensure that the generator was called with the user instance
    assert called["args"] is user
