import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest
from types import SimpleNamespace
from unittest.mock import Mock

try:
    import conduit.apps.authentication.models as auth_models
    from conduit.apps.authentication.serializers import RegistrationSerializer
    import conduit.apps.authentication.signals as auth_signals
    import conduit.apps.core.exceptions as core_ex
    from conduit.apps.core.utils import generate_random_string
    import rest_framework.exceptions as rf_exceptions
except ImportError:
    pytest.skip("Project-specific modules not available", allow_module_level=True)


def test_get_short_name_returns_username_and_type():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    get_short_name = auth_models.User.get_short_name  # unbound method
    fake_user = SimpleNamespace(username="alice")

    # Act
    result = get_short_name(fake_user)

    # Assert
    assert isinstance(result, str)
    assert result == "alice"


def test__generate_jwt_token_calls_jwt_encode_with_id_and_exp(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    captured = {}

    def fake_encode(payload, secret, algorithm="HS256"):
        # Capture payload for assertions and return a sentinel token
        captured['payload'] = payload
        captured['secret'] = secret
        captured['algorithm'] = algorithm
        return "FAKE.TOKEN.VALUE"

    # Monkeypatch the jwt.encode used inside the module
    monkeypatch.setattr(auth_models, "jwt", SimpleNamespace(encode=fake_encode))
    # Provide a fake SECRET_KEY if the function accesses settings; set on module if referenced
    if hasattr(auth_models, "settings"):
        # ensure SECRET_KEY exists
        setattr(auth_models.settings, "SECRET_KEY", "testsecret")
    else:
        # in case settings imported under a different name, safe-guard by injecting attribute
        setattr(auth_models, "settings", SimpleNamespace(SECRET_KEY="testsecret"))

    fake_user = SimpleNamespace(pk=42)

    # Act
    token = auth_models.User._generate_jwt_token(fake_user)

    # Assert
    assert token == "FAKE.TOKEN.VALUE"
    assert 'payload' in captured
    assert captured['payload']['id'] == 42
    assert isinstance(captured['payload']['exp'], int)
    assert captured['algorithm'] == "HS256"


def test_registration_serializer_validate_raises_on_password_mismatch():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    serializer = RegistrationSerializer()
    attrs = {"password": "one", "password2": "two"}

    # Act / Assert
    with pytest.raises(rf_exceptions.ValidationError):
        # call unbound instance method
        serializer.validate(attrs)


def test_create_related_profile_calls_get_or_create_only_on_created(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    calls = {}

    fake_get_or_create = Mock(return_value=(SimpleNamespace(), True))

    # Replace Profile in the signals module with a fake that has objects.get_or_create
    monkeypatch.setattr(auth_signals, "Profile", SimpleNamespace(objects=SimpleNamespace(get_or_create=fake_get_or_create)))

    fake_instance = SimpleNamespace(id=7, username="u")

    # Act: created=True should trigger profile creation
    auth_signals.create_related_profile(sender=None, instance=fake_instance, created=True, raw=False, using=None)

    # Assert
    assert fake_get_or_create.called
    # Expect it was called with user=fake_instance (common implementation)
    args, kwargs = fake_get_or_create.call_args
    assert "user" in kwargs
    assert kwargs["user"] is fake_instance

    fake_get_or_create.reset_mock()

    # Act: created=False should not trigger profile creation
    auth_signals.create_related_profile(sender=None, instance=fake_instance, created=False, raw=False, using=None)

    # Assert
    assert not fake_get_or_create.called


def test_core_exception_handler_routes_to_correct_helpers(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Provide sentinel return values from handlers
    generic_response = SimpleNamespace(status_code=500, data={"error": "generic"})
    not_found_response = SimpleNamespace(status_code=404, data={"error": "notfound"})

    monkeypatch.setattr(core_ex, "_handle_generic_error", lambda exc, ctx: generic_response)
    monkeypatch.setattr(core_ex, "_handle_not_found_error", lambda exc, ctx: not_found_response)

    # Create a dummy Http404 class and ensure the module uses it for isinstance checks
    class Dummy404(Exception):
        pass

    monkeypatch.setattr(core_ex, "Http404", Dummy404)

    # Act: pass a 404-like exception
    resp_nf = core_ex.core_exception_handler(Dummy404("nope"), {})

    # Assert
    assert resp_nf is not None
    assert getattr(resp_nf, "status_code", None) == 404
    assert getattr(resp_nf, "data", {}).get("error") == "notfound"

    # Act: pass a generic exception
    resp_gen = core_ex.core_exception_handler(Exception("boom"), {})

    # Assert
    assert resp_gen is not None
    assert getattr(resp_gen, "status_code", None) == 500
    assert getattr(resp_gen, "data", {}).get("error") == "generic"


@pytest.mark.parametrize("length", [0, 8, 16])
def test_generate_random_string_returns_string_of_requested_length(length):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act
    result = generate_random_string(length)

    # Assert
    assert isinstance(result, str)
    assert len(result) == length
    # characters should be alphanumeric (common implementation)
    assert all(ch.isalnum() for ch in result) or result == ""
