import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    import pytest
    from types import SimpleNamespace
    from unittest import mock

    # Target imports
    import conduit.apps.articles.signals as signals
    from conduit.apps.authentication import backends as auth_backends
    from conduit.apps.articles import views as article_views
    from conduit.apps.articles.views import CommentsDestroyAPIView, ArticleViewSet
    import rest_framework.exceptions as drf_exceptions
    from rest_framework.response import Response
except ImportError:
    import pytest
    pytest.skip("Required third-party or target modules not available", allow_module_level=True)


def test_add_slug_to_article_if_not_exists_creates_slug_and_preserves_existing():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyArticle:
        def __init__(self, title=None, slug=None):
            self.title = title
            self.slug = slug

    # Case A: slug is missing -> function should set a non-empty string slug
    article_no_slug = DummyArticle(title="A Test Article", slug=None)

    # Act
    # signal signature: (sender, instance, created, **kwargs)
    signals.add_slug_to_article_if_not_exists(sender=None, instance=article_no_slug, created=True)

    # Assert
    assert isinstance(article_no_slug.slug, str) and article_no_slug.slug, "Slug was not assigned when missing"

    # Case B: slug already exists -> should remain unchanged
    original = "existing-slug"
    article_with_slug = DummyArticle(title="Another", slug=original)
    signals.add_slug_to_article_if_not_exists(sender=None, instance=article_with_slug, created=True)
    assert article_with_slug.slug == original, "Existing slug should not be overwritten"


def test_jwtauthentication_authenticate_invalid_token_raises_authentication_failed(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = auth_backends.JWTAuthentication()
    # Build a minimal request-like object with an Authorization header
    request = SimpleNamespace(META={"HTTP_AUTHORIZATION": "Token badtoken"}, headers={"Authorization": "Token badtoken"})

    # Force the jwt.decode used inside the backend to raise an exception (simulate invalid token)
    # Some backend implementations import jwt as a module inside the module; patch that attribute on the module.
    def fake_decode(*args, **kwargs):
        raise Exception("Invalid token during decode")

    monkeypatch.setattr(auth_backends, "jwt", mock.MagicMock(decode=fake_decode), raising=False)

    # Act / Assert - expect DRF AuthenticationFailed (or similar) to be raised by authenticate path
    expected_exc = getattr(drf_exceptions, "AuthenticationFailed", Exception)
    with pytest.raises(expected_exc):
        auth.authenticate(request)


@pytest.mark.parametrize(
    "query_params, expect_filtered",
    [
        ({}, False),  # no filters -> original queryset returned
        ({"tag": "python"}, True),  # tag filter should attempt to filter
        ({"author": "alice"}, True),  # author filter should attempt to filter
        ({"favorited": "bob"}, True),  # favorited filter should attempt to filter
    ],
)
def test_articleviewset_filter_queryset_applies_filters(query_params, expect_filtered):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake queryset that records whether filter() was called
    class FakeQuerySet:
        def __init__(self):
            self.operations = []

        def filter(self, *args, **kwargs):
            self.operations.append(("filter", args, kwargs))
            return self

        def exclude(self, *args, **kwargs):
            self.operations.append(("exclude", args, kwargs))
            return self

        # Some implementations may call .distinct() or .select_related(), keep them no-ops
        def distinct(self, *args, **kwargs):
            self.operations.append(("distinct", args, kwargs))
            return self

    fake_qs = FakeQuerySet()

    view = ArticleViewSet()
    # Provide a request-like object with query_params attribute
    view.request = SimpleNamespace(query_params=query_params)
    # Ensure get_queryset returns our fake queryset
    view.get_queryset = lambda: fake_qs

    # Act
    result_qs = view.filter_queryset(fake_qs)

    # Assert
    assert result_qs is fake_qs, "filter_queryset should return the same queryset instance (or modified same instance)"
    if expect_filtered:
        # Expect at least one filter or exclude operation was performed
        has_filter_ops = any(op[0] in ("filter", "exclude") for op in fake_qs.operations)
        assert has_filter_ops, f"Expected queryset to be filtered for params {query_params}, operations: {fake_qs.operations}"
    else:
        # No operations expected
        assert fake_qs.operations == [], f"Did not expect filtering operations but found: {fake_qs.operations}"


def test_comments_destroy_view_delete_calls_delete_and_returns_204():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    view = CommentsDestroyAPIView()

    # Create a dummy comment object that tracks deletion
    class DummyComment:
        def __init__(self):
            self.deleted = False

        def delete(self):
            self.deleted = True
            # Many Django model delete() return a tuple; but view typically ignores return
            return (1, {"conduit.Comment": 1})

    dummy = DummyComment()

    # Patch get_object to return our dummy comment
    view.get_object = lambda: dummy

    # Act
    resp = view.delete(request=SimpleNamespace())  # call delete with a minimal request

    # Assert
    # The view should have called the model's delete method
    assert getattr(dummy, "deleted", False) is True, "Expected the comment object's delete() to be called"

    # And response should be a DRF Response with status_code 204 (No Content)
    assert isinstance(resp, Response), "Expected a DRF Response to be returned"
    assert getattr(resp, "status_code", None) in (204, None, 200) and getattr(resp, "status_code", None) == 204, (
        "Expected response status_code 204 for successful delete"
    )
