import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest

try:
    import random
    import string
    import jwt
    from rest_framework.exceptions import NotFound
    from rest_framework.response import Response
    from conduit.apps.core.exceptions import core_exception_handler, _handle_generic_error, _handle_not_found_error
    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.authentication.models import User
except ImportError as e:
    pytest.skip("Skipping tests because a required dependency is missing: {}".format(e), allow_module_level=True)


@pytest.mark.parametrize("length", [0, 12])
def test_generate_random_string_lengths_and_characters(length):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    random.seed(0)  # deterministic output
    allowed = set(string.ascii_letters + string.digits)

    # Act
    result = generate_random_string(length)

    # Assert
    assert isinstance(result, str)
    assert len(result) == length
    # every character should be from allowed set
    assert all((c in allowed) for c in result)


def test_generate_random_string_non_int_raises_typeerror():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    random.seed(0)

    # Act / Assert
    with pytest.raises(TypeError):
        generate_random_string("not-an-int")


@pytest.mark.parametrize("exc, expected_status", [
    (NotFound(detail="no resource"), 404),
    (Exception("generic failure"), 500),
])
def test_core_exception_handler_returns_response_and_status_codes(exc, expected_status):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    context = {}

    # Act
    resp = core_exception_handler(exc, context)

    # Assert
    assert isinstance(resp, Response)
    assert isinstance(resp.status_code, int)
    assert resp.status_code == expected_status
    # response data should be a mapping/dict-like
    assert isinstance(resp.data, dict)


def test_user_get_short_name_and_generate_jwt_token_contains_payload_keys():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    u = User()
    # set typical attributes without saving to DB
    setattr(u, "username", "alice")
    setattr(u, "email", "alice@example.test")
    # set a primary key to simulate persisted user
    setattr(u, "pk", 123)

    # Act
    short_name = u.get_short_name()
    token = u._generate_jwt_token()

    # Assert - get_short_name returns a string (typically username)
    assert isinstance(short_name, str)
    assert short_name in (u.username, u.email)

    # token should be a string
    assert isinstance(token, str)

    # Try to decode token without verifying signature/exp to inspect payload
    payload = jwt.decode(token, options={"verify_signature": False, "verify_exp": False})
    assert isinstance(payload, dict)
    # payload should contain at least one identifier/key we can recognize
    assert any(k in payload for k in ("id", "user_id", "username", "email"))
