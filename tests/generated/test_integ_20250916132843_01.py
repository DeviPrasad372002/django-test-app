import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from unittest.mock import MagicMock
    from datetime import datetime, timezone

    # application modules under test
    from conduit.apps.articles.signals import add_slug_to_article_if_not_exists
    from conduit.apps.articles.relations import TagRelatedField
    import conduit.apps.articles.relations as relations_module
    import conduit.apps.articles.signals as signals_module
    import conduit.apps.articles.serializers as articles_serializers_module
    from rest_framework import serializers as drf_serializers
except ImportError:
    import pytest
    pytest.skip("Required application or third-party modules not available", allow_module_level=True)


def test_add_slug_to_article_if_not_exists_creates_and_preserves_slug(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyArticle:
        def __init__(self, title, slug=None):
            self.title = title
            self.slug = slug

    # Ensure slugify deterministic for test
    monkeypatch.setattr(signals_module, "slugify", lambda s: "my-test-article")
    # Also ensure random generator not used in this simple path
    monkeypatch.setattr(signals_module, "generate_random_string", lambda n=6: "abcdef")

    # Act & Assert - case 1: slug is None -> created from title
    article1 = DummyArticle("My Test Article", slug=None)
    # call receiver as Django would (sender, instance, **kwargs)
    add_slug_to_article_if_not_exists(None, instance=article1)
    assert isinstance(article1.slug, str)
    assert article1.slug == "my-test-article"

    # Act & Assert - case 2: slug already exists -> not overwritten
    article2 = DummyArticle("Different Title", slug="existing-slug")
    add_slug_to_article_if_not_exists(None, instance=article2)
    assert article2.slug == "existing-slug"


@pytest.mark.parametrize(
    "input_value, expected_name, should_raise",
    [
        ("python", "python", False),
        ("py th on", "py-th-on", False),
        ("", None, True),  # edge case: empty tag should raise validation error
    ],
)
def test_tagrelatedfield_to_internal_and_representation(monkeypatch, input_value, expected_name, should_raise):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake Tag model with a simple objects.get_or_create behavior
    class FakeTag:
        def __init__(self, name):
            self.name = name

        def __repr__(self):
            return f"<FakeTag {self.name}>"

    class FakeManager:
        def get_or_create(self, name):
            # normal behavior: return tuple (instance, created_bool)
            return (FakeTag(name), True)

    FakeTag.objects = FakeManager()

    # Monkeypatch the Tag class used inside the relations module
    monkeypatch.setattr(relations_module, "Tag", FakeTag)
    # Also monkeypatch slugify used inside the relations if any for representation
    monkeypatch.setattr(relations_module, "slugify", lambda s: s.replace(" ", "-"))

    field = TagRelatedField()

    # Act / Assert
    if should_raise:
        with pytest.raises(drf_serializers.ValidationError):
            # Act
            field.to_internal_value(input_value)
    else:
        # Act
        tag_obj = field.to_internal_value(input_value)
        # Assert internal value is a FakeTag instance with expected name
        assert isinstance(tag_obj, FakeTag)
        assert getattr(tag_obj, "name") == expected_name

        # Act representation
        rep = field.to_representation(tag_obj)
        # Assert representation is a str matching the tag name
        assert isinstance(rep, str)
        assert rep == expected_name


def test_article_serializer_dates_and_favorites_integration(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class FakeFavorites:
        def __init__(self, count):
            self._count = count

        def count(self):
            return self._count

    class FakeArticle:
        def __init__(self, created_at=None, updated_at=None, favorites_count=0):
            self.created_at = created_at
            self.updated_at = updated_at
            # some implementations expose .favorites which supports count()
            self.favorites = FakeFavorites(favorites_count)

    # Fake has_favorited function to be used by the serializer module
    def fake_has_favorited(article, user):
        # return True only when user has id == 1 for deterministic behavior
        return getattr(user, "id", None) == 1

    # Monkeypatch the has_favorited that ArticleSerializer would call internally.
    # Depending on implementation it might import from profiles.models; patch in module under test.
    monkeypatch.setattr(articles_serializers_module, "has_favorited", fake_has_favorited)

    # Create serializer instance with a fake request context containing a user
    fake_request_user_true = MagicMock()
    fake_request_user_true.id = 1
    fake_request_user_false = MagicMock()
    fake_request_user_false.id = 99

    serializer_with_user_true = articles_serializers_module.ArticleSerializer(context={"request": MagicMock(user=fake_request_user_true)})
    serializer_with_user_false = articles_serializers_module.ArticleSerializer(context={"request": MagicMock(user=fake_request_user_false)})

    # Normal case: article has timestamps and 5 favorites
    created = datetime(2020, 1, 2, 3, 4, 5, tzinfo=timezone.utc)
    updated = datetime(2021, 6, 7, 8, 9, 10, tzinfo=timezone.utc)
    article = FakeArticle(created_at=created, updated_at=updated, favorites_count=5)

    # Act & Assert - created_at formatting
    created_val = serializer_with_user_true.get_created_at(article)
    assert isinstance(created_val, str)
    assert created_val.startswith("2020-01-02")  # ISO-like formatting

    # Act & Assert - updated_at formatting
    updated_val = serializer_with_user_true.get_updated_at(article)
    assert isinstance(updated_val, str)
    assert updated_val.startswith("2021-06-07")

    # Act & Assert - favorites count
    fav_count = serializer_with_user_true.get_favorites_count(article)
    # Expect integer count returned from article.favorites.count()
    assert isinstance(fav_count, int)
    assert fav_count == 5

    # Act & Assert - favorited when user id == 1 (patched behavior)
    is_favorited_true = serializer_with_user_true.get_favorited(article)
    assert isinstance(is_favorited_true, bool)
    assert is_favorited_true is True

    # Act & Assert - favorited when different user
    is_favorited_false = serializer_with_user_false.get_favorited(article)
    assert isinstance(is_favorited_false, bool)
    assert is_favorited_false is False

    # Edge case: missing timestamps should not raise, should return None or empty string depending on implementation
    article_no_dates = FakeArticle(created_at=None, updated_at=None, favorites_count=0)
    created_none = serializer_with_user_true.get_created_at(article_no_dates)
    updated_none = serializer_with_user_true.get_updated_at(article_no_dates)
    # Accept either None or string; check types accordingly
    assert created_none is None or isinstance(created_none, str)
    assert updated_none is None or isinstance(updated_none, str)
