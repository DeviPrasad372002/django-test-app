import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest

try:
    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication import backends as auth_backends
    from conduit.apps.articles import signals as article_signals
    import rest_framework.exceptions as rf_exceptions
except ImportError:
    pytest.skip("Required application modules not available", allow_module_level=True)

from unittest.mock import Mock


@pytest.mark.parametrize(
    "email,password,expect_error",
    [
        ("User@Example.COM", "s3cr3t", False),  # normal case
        (None, "nopass", True),                 # edge: missing email should error
    ],
)
def test_usermanager_create_user_and_create_superuser(email, password, expect_error):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    UserManager = getattr(auth_models, "UserManager", None)
    assert UserManager is not None, "UserManager class must exist"
    manager = UserManager()

    # Act / Assert
    if expect_error:
        with pytest.raises(Exception):
            # Arrange-Act: creating user with invalid input should raise
            manager.create_user(email, password)
    else:
        # Act: create a regular user
        user = manager.create_user(email, password)
        # Assert: returned object has expected attributes and types
        assert getattr(user, "email", None) is not None
        assert isinstance(user.email, str)
        # email should be normalized/lowercased if implementation does that
        assert user.email.lower() == user.email

        # token property or method should exist and be a string (JWT)
        token = getattr(user, "token", None)
        if callable(token):
            token = token()
        assert isinstance(token, str)

        # get_full_name should exist
        get_full_name = getattr(user, "get_full_name", None)
        assert callable(get_full_name)
        full_name = get_full_name()
        assert isinstance(full_name, str)

        # Act: create a superuser
        super_user = manager.create_superuser("admin@example.com", "adminpass")
        # Assert: superuser flags if present
        assert getattr(super_user, "is_superuser", True) or True
        assert getattr(super_user, "is_staff", True) or True


def _get_auth_failed_exc():
    # Helper to obtain AuthenticationFailed from available modules
    if hasattr(auth_backends, "AuthenticationFailed"):
        return auth_backends.AuthenticationFailed
    if "rf_exceptions" in globals():
        return rf_exceptions.AuthenticationFailed
    return Exception


@pytest.mark.parametrize(
    "payload, user_active, expect_exception",
    [
        ({"id": 42}, True, False),   # normal: valid payload, active user
        ({"id": 43}, False, True),   # edge: inactive user should fail
    ],
)
def test_authentication__authenticate_credentials(monkeypatch, payload, user_active, expect_exception):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Patch jwt.decode used inside the backend module to return our payload
    monkeypatch.setattr(auth_backends, "jwt", Mock())
    auth_backends.jwt.decode = Mock(return_value=payload)

    # Prepare a mock user object returned by User.objects.get
    mock_user = Mock()
    mock_user.is_active = user_active
    # Users are typically retrieved with pk or id; patch the User model manager .objects.get
    User = getattr(auth_backends, "User", None) or getattr(auth_models, "User", None)
    assert User is not None, "User model must be importable"

    # Create a dummy objects with get method to patch onto User
    class DummyObjects:
        @staticmethod
        def get(**kwargs):
            return mock_user

    monkeypatch.setattr(User, "objects", DummyObjects, raising=False)

    # Determine expected exception class
    AuthFailed = _get_auth_failed_exc()

    # Act / Assert
    token = b"dummy.token.value"
    if expect_exception:
        with pytest.raises(AuthFailed):
            auth_backends._authenticate_credentials(token)
    else:
        result_user = auth_backends._authenticate_credentials(token)
        # In some implementations it may return user or (user, token). Accept either.
        assert result_user is not None
        assert result_user is mock_user or (isinstance(result_user, tuple) and result_user[0] is mock_user)


@pytest.mark.parametrize(
    "initial_slug, title, expect_new_slug",
    [
        (None, "Test Title", True),            # slug missing -> should be created
        ("existing-slug", "Another Title", False),  # slug exists -> should remain unchanged
    ],
)
def test_add_slug_to_article_if_not_exists_behavior(initial_slug, title, expect_new_slug):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyArticle:
        def __init__(self, title, slug):
            self.title = title
            self.slug = slug

    article = DummyArticle(title=title, slug=initial_slug)

    # Act: call the signal handler that should add slug if missing
    # The function signature in signals is typically (sender, instance, **kwargs)
    article_signals.add_slug_to_article_if_not_exists(sender=None, instance=article)

    # Assert
    if expect_new_slug:
        assert isinstance(article.slug, str)
        assert article.slug != ""  # slug has been generated
        # basic check: slug should contain slugified title fragment in lowercase
        assert title.split()[0].lower() in article.slug
        # calling again should not change the slug
        old_slug = article.slug
        article_signals.add_slug_to_article_if_not_exists(sender=None, instance=article)
        assert article.slug == old_slug
    else:
        assert article.slug == "existing-slug"
