import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from types import SimpleNamespace

    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.core import exceptions as core_excs

    # rest_framework is a third-party dependency; if missing, skip at module level
    try:
        from rest_framework.exceptions import NotFound
        from rest_framework.response import Response
    except ImportError:
        pytest.skip("rest_framework not available", allow_module_level=True)

except ImportError:
    import pytest
    pytest.skip("required modules for tests not available", allow_module_level=True)


def test_generate_random_string_normal_and_zero_length(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Provide a deterministic sequence of characters for random.choice
    seq = iter(list("abcdef"))
    def fake_choice(_):
        return next(seq)
    monkeypatch.setattr("conduit.apps.core.utils.random.choice", fake_choice)

    # Act & Assert - normal length
    result = generate_random_string(3)
    # Assert: deterministic and string type and expected content from our fake_choice
    assert isinstance(result, str)
    assert result == "abc"

    # Act & Assert - zero length should return empty string
    result_zero = generate_random_string(0)
    assert isinstance(result_zero, str)
    assert result_zero == ""


@pytest.mark.parametrize("raise_on_choice, expected_exception", [
    (True, RuntimeError),
    (False, None),
])
def test_generate_random_string_error_path(monkeypatch, raise_on_choice, expected_exception):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    def fake_choice_err(_):
        raise RuntimeError("random failure")
    if raise_on_choice:
        monkeypatch.setattr("conduit.apps.core.utils.random.choice", fake_choice_err)

    # Act / Assert
    if raise_on_choice:
        with pytest.raises(expected_exception):
            generate_random_string(5)
    else:
        # restore a benign choice
        monkeypatch.setattr("conduit.apps.core.utils.random.choice", lambda _: "x")
        out = generate_random_string(4)
        assert out == "xxxx"


def test__generate_jwt_token_payload_and_error(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class DummyUser:
        id = 42

    captured = {}

    def fake_encode(payload, key, algorithm="HS256"):
        # Capture payload for assertions and return deterministic token
        captured['payload'] = payload
        captured['key'] = key
        return "deterministic-token-42"

    monkeypatch.setattr(auth_models, "jwt", SimpleNamespace(encode=fake_encode))

    # Act
    token = auth_models.User._generate_jwt_token(DummyUser())

    # Assert - token matches fake encode return and payload contains id and exp
    assert token == "deterministic-token-42"
    assert isinstance(captured.get("payload"), dict)
    assert captured["payload"].get("id") == 42
    assert "exp" in captured["payload"]
    # exp should be an int or float (timestamp)
    assert isinstance(captured["payload"]["exp"], (int, float))

    # Error path: make jwt.encode raise and ensure exception propagates
    def fake_encode_raises(payload, key, algorithm="HS256"):
        raise ValueError("jwt encode failed")
    monkeypatch.setattr(auth_models, "jwt", SimpleNamespace(encode=fake_encode_raises))

    with pytest.raises(ValueError):
        auth_models.User._generate_jwt_token(DummyUser())


def test_user_json_renderer_render_outputs_bytes_and_contains_expected_keys():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()
    data = {"user": {"email": "tester@example.com", "username": "tester"}}

    # Act
    output = renderer.render(data, media_type=None, renderer_context=None)

    # Assert
    # Output should be bytes or str depending on implementation; normalize to bytes for checks
    assert isinstance(output, (bytes, str))
    out_bytes = output if isinstance(output, bytes) else output.encode("utf-8")
    assert b'"email"' in out_bytes
    assert b"tester@example.com" in out_bytes
    assert b'"username"' in out_bytes
    assert b"tester" in out_bytes


@pytest.mark.parametrize("exc, expected_status", [
    (NotFound("not found"), 404),
    (Exception("generic"), 500),
])
def test_core_exception_handler_dispatch_and_status(exc, expected_status):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    context = {}

    # Act
    response = core_excs.core_exception_handler(exc, context)

    # Assert basic shape and status code
    assert isinstance(response, Response)
    assert isinstance(response.status_code, int)
    assert response.status_code == expected_status
    # Response data should include "errors" or some mapping
    assert hasattr(response, "data")
    assert isinstance(response.data, (dict, list, str, type(None)))
