import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import json
    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.authentication.backends import JWTAuthentication
except ImportError as e:
    import pytest
    pytest.skip(f"skipping tests: missing dependencies: {e}", allow_module_level=True)


@pytest.mark.parametrize(
    "input_data,expected_output",
    [
        ({"username": "alice", "token": "t-123"}, {"user": {"username": "alice", "token": "t-123"}}),
        ({"errors": {"email": ["invalid"]}}, {"errors": {"email": ["invalid"]}}),
    ],
)
def test_userjsonrenderer_renders_expected_top_level_key(input_data, expected_output):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()

    # Act
    rendered = renderer.render(input_data)

    # Assert: renderer should return bytes or str JSON
    assert isinstance(rendered, (bytes, str)), "Renderer must return bytes or str"
    decoded = rendered.decode("utf-8") if isinstance(rendered, bytes) else rendered
    parsed = json.loads(decoded)
    assert parsed == expected_output


def test_jwtauthentication_authenticate_calls_internal_and_handles_missing_header(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()
    recorded = {}

    def fake_authenticate_credentials(token):
        # record the token and return a predictable tuple as the real method would
        recorded["token"] = token
        return ("user_object_stub", "token_stub")

    # Replace the internal credential authenticator with our fake
    monkeypatch.setattr(auth, "_authenticate_credentials", fake_authenticate_credentials)

    class DummyRequest:
        def __init__(self, meta):
            self.META = meta

    # Act & Assert: When no Authorization header is present, authenticate should return None
    req_no_header = DummyRequest(meta={})
    result_no_header = auth.authenticate(req_no_header)
    assert result_no_header is None

    # Act & Assert: When Authorization header present with expected prefix, internal method is invoked
    req_with_header = DummyRequest(meta={"HTTP_AUTHORIZATION": "Token my-secret-token"})
    result = auth.authenticate(req_with_header)
    assert result == ("user_object_stub", "token_stub")
    assert recorded.get("token") == "my-secret-token"
