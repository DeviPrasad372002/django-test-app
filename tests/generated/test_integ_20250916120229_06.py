import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import json
    import types
    import datetime
    from unittest import mock

    import pytest

    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication import backends as auth_backends
    from conduit.apps.authentication import renderers as auth_renderers
    from conduit.apps.core import utils as core_utils
    from rest_framework.exceptions import AuthenticationFailed
except ImportError:
    import pytest
    pytest.skip("Required application modules or third-party packages not available", allow_module_level=True)


def test_generate_jwt_token_and_token_property(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    captured = {}

    def fake_encode(payload, key, algorithm):
        # capture payload for inspection and return deterministic token
        captured['payload'] = payload
        return "deterministic.jwt.token"

    # Ensure we patch the jwt.encode used in the models module
    monkeypatch.setattr(auth_models, "jwt", types.SimpleNamespace(encode=fake_encode))

    # Act
    user = auth_models.User(email="tester@example.com", username="tester")
    generated = user._generate_jwt_token()
    prop = user.token  # property that should call _generate_jwt_token internally

    # Assert
    assert isinstance(generated, str)
    assert generated == "deterministic.jwt.token"
    assert isinstance(prop, str)
    assert prop == "deterministic.jwt.token"
    # payload should be a dict (contains expiry/user id etc.)
    assert isinstance(captured.get("payload"), dict)


@pytest.mark.parametrize(
    "jwt_side_effect, expected_exception",
    [
        ({"user_id": 1}, None),  # valid token payload -> should return user
        (Exception("invalid token"), AuthenticationFailed),  # decode error -> AuthenticationFailed
    ],
)
def test_jwt_authentication_authenticate_credentials(monkeypatch, jwt_side_effect, expected_exception):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    jwt_called = {}

    def fake_decode_success(token, key, algorithms):
        jwt_called['called_with'] = token
        return jwt_side_effect

    def fake_decode_raise(token, key, algorithms):
        raise jwt_side_effect

    # Prepare a fake user and manager
    class FakeUser:
        def __init__(self):
            self.username = "fake"
            self.email = "fake@example.com"

    class FakeManager:
        def __init__(self, user):
            self._user = user

        def get(self, **kwargs):
            # accept either pk or id lookups
            if kwargs.get("pk") in (1, None) or kwargs.get("id") in (1, None):
                return self._user
            raise Exception("Not found")

    fake_user = FakeUser()
    fake_manager = FakeManager(fake_user)

    # Patch the auth_backends module's jwt.decode and User reference
    if isinstance(jwt_side_effect, Exception):
        monkeypatch.setattr(auth_backends, "jwt", types.SimpleNamespace(decode=fake_decode_raise))
    else:
        monkeypatch.setattr(auth_backends, "jwt", types.SimpleNamespace(decode=fake_decode_success))

    # Replace the User model reference used in the backend with our fake
    monkeypatch.setattr(auth_backends, "User", types.SimpleNamespace(objects=fake_manager))

    # Act / Assert
    backend = auth_backends.JWTAuthentication()
    if expected_exception is None:
        # should return a user for valid token
        user = backend._authenticate_credentials("sometoken")
        assert user is fake_user
        assert jwt_called.get("called_with") == "sometoken"
    else:
        with pytest.raises(expected_exception):
            backend._authenticate_credentials("badtoken")


def test_user_json_renderer_renders_expected_structure():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = auth_renderers.UserJSONRenderer()
    payload = {"user": {"email": "a@b.com", "username": "ab", "token": "tok123"}}

    # Act
    rendered = renderer.render(payload)

    # Assert
    # renderer should return bytes (JSON) or str depending on implementation; accept both but validate content
    assert isinstance(rendered, (bytes, str))
    text = rendered.decode("utf-8") if isinstance(rendered, bytes) else rendered
    parsed = json.loads(text)
    assert isinstance(parsed, dict)
    assert "user" in parsed
    assert parsed["user"]["email"] == "a@b.com"
    assert parsed["user"]["username"] == "ab"
    assert parsed["user"]["token"] == "tok123"


def test_generate_random_string_properties():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act
    s1 = core_utils.generate_random_string(8)
    s2 = core_utils.generate_random_string(12)

    # Assert basic properties: lengths, types, and character set
    assert isinstance(s1, str)
    assert isinstance(s2, str)
    assert len(s1) == 8
    assert len(s2) == 12

    allowed = set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
    assert set(s1).issubset(allowed)
    assert set(s2).issubset(allowed)
