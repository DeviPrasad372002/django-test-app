import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    import json
    from conduit.apps.core.utils import generate_random_string
    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication.renderers import UserJSONRenderer
    from conduit.apps.core.exceptions import core_exception_handler, _handle_not_found_error, _handle_generic_error
    from rest_framework.exceptions import NotFound
except ImportError:
    import pytest
    pytest.skip("Skipping tests - required third-party packages or target modules are not available", allow_module_level=True)


def test_generate_random_string_normal_and_zero():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    lengths = [8, 0]
    # Act & Assert
    for length in lengths:
        result = generate_random_string(length)
        # Assert type and length
        assert isinstance(result, str)
        assert len(result) == length
        # When length is zero, string should be empty
        if length == 0:
            assert result == ""
        else:
            # For normal length, ensure characters are alphanumeric (letters/digits/underscores depending on impl)
            # At minimum ensure it's not all whitespace and is printable
            assert any(ch.isalnum() for ch in result)


def test_user__generate_jwt_token_calls_jwt_encode_and_includes_id(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    User = auth_models.User
    user = User()
    # simulate saved user id
    user.id = 42

    captured = {}

    def fake_encode(payload, secret, algorithm="HS256"):
        # capture payload for assertions and return deterministic token
        captured['payload'] = payload
        captured['secret'] = secret
        captured['algorithm'] = algorithm
        return "FAKE.JWT.TOKEN"

    # Ensure we monkeypatch the jwt.encode used inside the auth_models module
    monkeypatch.setattr(auth_models.jwt, "encode", fake_encode)

    # Act
    token = user._generate_jwt_token()

    # Assert
    assert token == "FAKE.JWT.TOKEN"
    assert isinstance(captured.get('payload'), dict)
    # The payload should include the user's id (often under 'id' or 'user_id'); check common keys
    payload = captured['payload']
    assert ('id' in payload and payload['id'] == 42) or ('user_id' in payload and payload['user_id'] == 42)


def test_userjsonrenderer_renders_user_and_errors():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = UserJSONRenderer()

    user_payload = {'username': 'alice', 'email': 'alice@example.com'}
    errors_payload = {'errors': {'email': ['invalid']}}

    # Act
    rendered_user = renderer.render(user_payload)
    rendered_errors = renderer.render(errors_payload)

    # Assert
    # Renderer should produce bytes (JSON) or str; handle both
    for rendered, key in ((rendered_user, 'username'), (rendered_errors, 'errors')):
        assert isinstance(rendered, (bytes, str))
        text = rendered.decode('utf-8') if isinstance(rendered, bytes) else rendered
        parsed = json.loads(text)
        # When rendering a user dict, typical renderer wraps it under 'user' key; allow either direct or wrapped.
        if key == 'username':
            assert (('user' in parsed and parsed['user']['username'] == 'alice') or parsed.get('username') == 'alice')
        else:
            assert 'errors' in parsed
            assert parsed['errors'] == errors_payload['errors']


def test_core_exception_handler_routes_not_found_and_generic_errors():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    context = {}

    # Act: NotFound
    not_found_exc = NotFound(detail="not found")
    not_found_response = core_exception_handler(not_found_exc, context)

    # Assert: NotFound should be mapped to 404
    assert hasattr(not_found_response, "status_code")
    assert not_found_response.status_code == 404
    # Response data should be a dict or contain information about the error
    assert isinstance(not_found_response.data, (dict, list))

    # Act: generic Exception should be handled by generic handler
    generic_exc = Exception("boom")
    generic_response = core_exception_handler(generic_exc, context)

    # Assert: generic exceptions should map to a 500-like response
    assert hasattr(generic_response, "status_code")
    assert generic_response.status_code in (500, 400, 422)  # allow possible implementations but expect server/error code
    assert isinstance(generic_response.data, (dict, list))
