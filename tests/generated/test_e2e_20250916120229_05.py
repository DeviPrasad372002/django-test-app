import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest as _pytest
_pytest.skip('generator: banned private imports detected; skipping module', allow_module_level=True)

try:
    import pytest
    import json
    import random
    from conduit.apps.articles.renderers import ArticleJSONRenderer, CommentJSONRenderer
    from conduit.apps.core.utils import generate_random_string
except ImportError:
    import pytest as _pytest
    _pytest.skip("Required modules for tests are not available", allow_module_level=True)


@pytest.mark.parametrize(
    "input_data",
    [
        {"title": "Hello", "body": "World"},  # normal dict
        {"title": "Nested", "tags": ["python", "testing"], "meta": {"views": 10}},  # nested structures
    ],
)
def test_articlejsonrenderer_wraps_payload_under_article_key(input_data):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create renderer instance and prepare input data (primitive-serializable)
    renderer = ArticleJSONRenderer()

    # Act: render the input data
    output_bytes = renderer.render(input_data)

    # Assert: output is bytes, valid JSON, and contains the original data under "article"
    assert isinstance(output_bytes, (bytes, bytearray))
    parsed = json.loads(output_bytes.decode("utf-8"))
    assert isinstance(parsed, dict)
    assert "article" in parsed
    assert parsed["article"] == input_data


@pytest.mark.parametrize(
    "input_data, expected_len",
    [
        ([{"id": 1, "body": "c1"}, {"id": 2, "body": "c2"}], 2),  # normal list of comments
        ([], 0),  # edge: empty list of comments
    ],
)
def test_commentjsonrenderer_wraps_list_under_comments_key(input_data, expected_len):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create renderer instance and prepare a list of comment dicts
    renderer = CommentJSONRenderer()

    # Act: render the input list
    output_bytes = renderer.render(input_data)

    # Assert: output is bytes, valid JSON, and contains "comments" key with expected list length
    assert isinstance(output_bytes, (bytes, bytearray))
    parsed = json.loads(output_bytes.decode("utf-8"))
    assert isinstance(parsed, dict)
    assert "comments" in parsed
    assert isinstance(parsed["comments"], list)
    assert len(parsed["comments"]) == expected_len
    # If not empty, ensure elements match exactly
    if expected_len > 0:
        assert parsed["comments"] == input_data


def test_generate_random_string_is_deterministic_with_seed_and_handles_zero_length():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: choose a length and set seed for determinism
    length = 10
    random.seed(12345)

    # Act: generate two strings with the same seed
    first = generate_random_string(length)
    # reseed to ensure deterministic repeatability
    random.seed(12345)
    second = generate_random_string(length)

    # Assert: same seed produces identical strings, correct type and length
    assert isinstance(first, str)
    assert isinstance(second, str)
    assert first == second
    assert len(first) == length

    # Arrange: test edge case length 0
    zero_length = 0

    # Act: generate string of length 0
    zero_str = generate_random_string(zero_length)

    # Assert: result is an empty string
    assert isinstance(zero_str, str)
    assert zero_str == ""
