import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    import pytest
    from unittest.mock import Mock
    from types import SimpleNamespace

    from conduit.apps.authentication import models as auth_models
    from conduit.apps.authentication import renderers as auth_renderers
    from conduit.apps.authentication import signals as auth_signals
    # serializers may not exist in every variant; handle gracefully at test level
    try:
        from conduit.apps.authentication import serializers as auth_serializers
    except Exception:
        auth_serializers = None

    from conduit.apps.profiles import models as profiles_models
    import rest_framework.exceptions as drf_exceptions
except Exception:
    import pytest
    pytest.skip("Required modules for integration tests are not available", allow_module_level=True)


def test_generate_jwt_and_get_short_name(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    user = SimpleNamespace(username="alice", email="alice@example.com", pk=123)
    # Ensure we have a _generate_jwt_token function
    gen_fn = getattr(auth_models, "_generate_jwt_token", None)
    get_short = getattr(auth_models, "get_short_name", None)
    if gen_fn is None or get_short is None:
        pytest.skip("_generate_jwt_token or get_short_name not present in auth_models")

    # Monkeypatch jwt.encode used by the implementation to a deterministic value
    fake_token = "fake.header.payload"
    jwt_module = getattr(auth_models, "jwt", None)
    if jwt_module is None:
        pytest.skip("jwt module not available inside auth_models")

    monkeypatch.setattr(jwt_module, "encode", lambda payload, key, algorithm=None: fake_token)

    # Act
    token = gen_fn(user)
    short = get_short(user)

    # Assert
    assert isinstance(token, str), "token should be a string"
    assert token == fake_token
    assert isinstance(short, str)
    assert short == "alice"


def test_generate_jwt_propagates_encode_errors(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    user = SimpleNamespace(username="bob", email="b@example.com", pk=9)
    gen_fn = getattr(auth_models, "_generate_jwt_token", None)
    if gen_fn is None:
        pytest.skip("_generate_jwt_token not present in auth_models")

    jwt_module = getattr(auth_models, "jwt", None)
    if jwt_module is None:
        pytest.skip("jwt module not available inside auth_models")

    # Make jwt.encode raise an error to ensure it's propagated (error path)
    def raise_encode(payload, key, algorithm=None):
        raise ValueError("encode failed")

    monkeypatch.setattr(jwt_module, "encode", raise_encode)

    # Act / Assert
    with pytest.raises(ValueError):
        gen_fn(user)


def test_userjsonrenderer_render_and_registration_validate(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange - render
    renderer_cls = getattr(auth_renderers, "UserJSONRenderer", None)
    if renderer_cls is None:
        pytest.skip("UserJSONRenderer not present in auth_renderers")

    renderer = renderer_cls()
    payload = {"user": {"email": "c@example.com", "username": "charlie"}}

    # Act - render
    rendered = renderer.render(payload)

    # Assert - render: should be bytes or str and contain email and username
    assert isinstance(rendered, (bytes, str))
    text = rendered.decode() if isinstance(rendered, bytes) else rendered
    assert "c@example.com" in text
    assert "charlie" in text

    # Arrange / Act / Assert - validate (if RegistrationSerializer exists)
    if auth_serializers is None:
        pytest.skip("authentication.serializers not available for validate tests")

    RegSerializer = getattr(auth_serializers, "RegistrationSerializer", None)
    if RegSerializer is None:
        pytest.skip("RegistrationSerializer not present in authentication.serializers")

    # Normal case: all required fields present
    serializer = RegSerializer(data={"user": {"username": "d", "email": "d@example.com", "password": "s3cr3t"}})
    valid = serializer.is_valid()
    assert valid is True, f"expected valid registration data, got errors: {getattr(serializer, 'errors', None)}"
    assert isinstance(serializer.validated_data, dict)

    # Edge case: missing password should produce validation errors
    serializer_missing = RegSerializer(data={"user": {"username": "e", "email": "e@example.com"}})
    is_valid_missing = serializer_missing.is_valid()
    assert is_valid_missing is False
    # error object/type check
    assert hasattr(serializer_missing, "errors")
    assert serializer_missing.errors, "Expected errors for missing password"


def test_create_related_profile_calls_profile_create(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    create_fn = getattr(auth_signals, "create_related_profile", None)
    if create_fn is None:
        pytest.skip("create_related_profile not present in authentication.signals")

    # Prepare a fake user instance
    user = SimpleNamespace(pk=42, username="frank")

    # Monkeypatch the Profile.objects.create to observe calls without DB
    try:
        Profile = getattr(profiles_models, "Profile")
        manager = getattr(Profile, "objects", None)
    except Exception:
        Profile = None
        manager = None

    if manager is None:
        # If the Profile manager isn't available, create a dummy holder and monkeypatch where referenced
        mock_create = Mock(return_value="created-profile")
        # set a fake Profile attribute on profiles_models for the signal to call
        fake_profile_cls = SimpleNamespace(objects=SimpleNamespace(create=mock_create))
        monkeypatch.setattr(profiles_models, "Profile", fake_profile_cls, raising=False)
    else:
        mock_create = Mock(return_value="created-profile")
        monkeypatch.setattr(Profile, "objects", SimpleNamespace(create=mock_create), raising=False)

    # Act: simulate post_save signal handler call when a user is created
    # create_related_profile signature typically (sender, instance, created, **kwargs)
    create_fn(sender=type(user), instance=user, created=True)

    # Assert: Profile.objects.create was called with user=user
    assert mock_create.called is True
    # It should be called with a keyword or positional argument referencing the user instance
    called_args, called_kwargs = mock_create.call_args
    assert any(arg is user for arg in called_args) or any(val is user for val in called_kwargs.values())


@pytest.mark.parametrize("initially_following", [False, True])
def test_follow_unfollow_and_is_following(initially_following):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: build lightweight managers compatible with expected usage in profile methods
    class DummyQuerySet(list):
        def exists(self):
            return bool(self)

    class DummyManager:
        def __init__(self):
            self._items = []

        def add(self, item):
            self._items.append(item)

        def remove(self, item):
            self._items = [i for i in self._items if i is not item]

        def all(self):
            return list(self._items)

        def filter(self, **kwargs):
            pk = kwargs.get("pk")
            if pk is None:
                return DummyQuerySet(self._items)
            return DummyQuerySet([i for i in self._items if getattr(i, "pk", None) == pk])

    follower = SimpleNamespace(pk=1, following=DummyManager())
    followee = SimpleNamespace(pk=2)

    # Optionally pre-populate following state
    if initially_following:
        follower.following.add(followee)

    # Grab functions; they might be methods on a class, but they are present in module as functions to call
    follow_fn = getattr(profiles_models, "follow", None)
    unfollow_fn = getattr(profiles_models, "unfollow", None)
    is_following_fn = getattr(profiles_models, "is_following", None)

    if not (follow_fn and unfollow_fn and is_following_fn):
        pytest.skip("follow/unfollow/is_following functions not present in profiles_models")

    # Act - follow (idempotent if already following)
    follow_fn(follower, followee)

    # Assert follow resulted in followee being present
    assert any(item is followee for item in follower.following.all()), "followee should be in follower.following after follow()"

    # Act - is_following
    is_now_following = is_following_fn(follower, followee)

    # Assert - is_following returns truthy
    assert bool(is_now_following) is True

    # Act - unfollow (should remove even if not present)
    unfollow_fn(follower, followee)

    # Assert - followee is no longer in following
    assert not any(item is followee for item in follower.following.all()) or (not follower.following.all()), "followee should not be in follower.following after unfollow()"

    # Edge: unfollow again should not raise
    unfollow_fn(follower, followee)
    assert True  # got here without exception indicating idempotency or safe no-op
