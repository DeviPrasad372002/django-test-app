import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from types import SimpleNamespace

    from conduit.apps.authentication.backends import JWTAuthentication
    from conduit.apps.authentication import backends as auth_backends_mod
    from conduit.apps.authentication import renderers as auth_renderers_mod
    from conduit.apps.authentication import serializers as auth_serializers_mod
    from conduit.apps.authentication import models as auth_models_mod
    from rest_framework import exceptions as drf_exceptions
except ImportError:
    import pytest
    pytest.skip("Required third-party or target modules are not available.", allow_module_level=True)


@pytest.mark.parametrize(
    "auth_header,jwt_decode_behavior,expect_exception",
    [
        # Normal case: jwt.decode returns payload dict with id -> authentication succeeds
        ("Token goodtoken", lambda token, key, algorithms: {"id": 1}, False),
        # Error case: jwt.decode raises an exception -> authentication fails with AuthenticationFailed
        ("Token invalidtoken", lambda token, key, algorithms: (_ for _ in ()).throw(Exception("invalid")), True),
        # Edge case: missing/blank header -> authenticate should return None (no credentials)
        ("", None, False),
    ],
)
def test_jwtauthentication_authenticate_various_cases(monkeypatch, auth_header, jwt_decode_behavior, expect_exception):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()

    # Prepare fake request object with META header as DRF expects
    request = SimpleNamespace(META={"HTTP_AUTHORIZATION": auth_header} if auth_header != "" else {})

    # Monkeypatch the jwt.decode used inside the authentication backend module if behavior provided
    if jwt_decode_behavior is not None:
        def fake_decode(token, key, algorithms):
            return jwt_decode_behavior(token, key, algorithms)
        # Ensure we patch the jwt.decode used by the authentication backend module
        monkeypatch.setattr(auth_backends_mod.jwt, "decode", fake_decode, raising=True)

    # Prepare a fake user lookup to avoid DB interaction
    fake_user = SimpleNamespace(pk=1, email="tester@example.com", is_active=True)
    class FakeManager:
        def get(self, **kwargs):
            # Simulate lookup by pk or id
            if kwargs.get("pk") in (1, "1") or kwargs.get("id") in (1, "1"):
                return fake_user
            raise auth_models_mod.User.DoesNotExist()

    # Replace User.objects with our fake manager
    monkeypatch.setattr(auth_models_mod.User, "objects", FakeManager(), raising=False)

    # Act / Assert
    if expect_exception:
        with pytest.raises(drf_exceptions.AuthenticationFailed):
            auth.authenticate(request)
    else:
        result = auth.authenticate(request)
        # If no Authorization header present, many DRF auth classes return None
        if auth_header == "":
            assert result is None
        else:
            # Assert a tuple (user, token) is returned
            assert isinstance(result, tuple)
            user, token = result
            assert user is fake_user
            assert token == auth_header.split(maxsplit=1)[1]


@pytest.mark.parametrize(
    "input_data,expected_contains",
    [
        ({"user": {"email": "a@b.com", "username": "alice", "token": "tok"}}, "a@b.com"),
        ({"user": {"username": "bob", "bio": "dev"}}, "bob"),
    ],
)
def test_user_json_renderer_renders_user_dict(monkeypatch, input_data, expected_contains):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = auth_renderers_mod.UserJSONRenderer()

    # Act
    rendered = renderer.render(input_data)

    # Assert
    # Accept either bytes or str output from renderer; ensure JSON/text contains expected string
    assert isinstance(rendered, (bytes, str))
    rendered_text = rendered.decode() if isinstance(rendered, bytes) else rendered
    assert expected_contains in rendered_text


@pytest.mark.parametrize(
    "payload,should_raise",
    [
        # Normal case: passwords match -> validate returns same dict (or at least does not raise)
        ({"email": "x@y.com", "username": "x", "password": "pass", "password_confirmation": "pass"}, False),
        # Error case: password mismatch -> ValidationError
        ({"email": "x@y.com", "username": "x", "password": "pass", "password_confirmation": "wrong"}, True),
        # Edge case: missing email -> ValidationError
        ({"username": "x", "password": "p", "password_confirmation": "p"}, True),
    ],
)
def test_registration_serializer_validate_behaviour(payload, should_raise):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Attempt to instantiate the serializer; many DRF serializers allow parameterless instantiation for validate()
    serializer_cls = auth_serializers_mod.RegistrationSerializer
    serializer = serializer_cls()

    # Act / Assert
    if should_raise:
        with pytest.raises(drf_exceptions.ValidationError):
            # The serializer's validate method typically expects the attrs dict
            serializer.validate(payload)
    else:
        validated = serializer.validate(payload)
        # Assert that the validated data is a dict and contains expected keys
        assert isinstance(validated, dict)
        assert validated.get("email") == payload.get("email")
        assert validated.get("username") == payload.get("username")
