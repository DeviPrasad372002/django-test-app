import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest
from types import SimpleNamespace

try:
    from target.conduit.apps.authentication.models import User
    from target.conduit.apps.authentication.backends import JWTAuthentication
    from target.conduit.apps.articles.views import ArticleViewSet
    from target.conduit.apps.articles.signals import add_slug_to_article_if_not_exists
    from target.conduit.apps.core import utils as core_utils
except ImportError as e:
    pytest.skip(f"Required project modules not available: {e}", allow_module_level=True)


def test_jwt_authentication_handles_missing_and_valid_authorization_header(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    auth = JWTAuthentication()

    class DummyRequest:
        def __init__(self, header_value):
            if header_value is None:
                self.META = {}
            else:
                self.META = {"HTTP_AUTHORIZATION": header_value}

    called = []

    def fake_auth_creds(self, token):
        # Act-capturing helper to verify token extraction
        called.append(token)
        return ("user_object", token)

    monkeypatch.setattr(JWTAuthentication, "_authenticate_credentials", fake_auth_creds, raising=False)

    # Parametrize two cases: missing header -> None, valid "Token <value>" -> returns tuple
    # Act & Assert - missing header
    req_missing = DummyRequest(None)
    res_missing = auth.authenticate(req_missing)
    assert res_missing is None  # no credentials -> authentication not attempted
    assert called == []  # helper not called

    # Act & Assert - valid header
    req_valid = DummyRequest("Token abc123")
    res_valid = auth.authenticate(req_valid)
    assert res_valid == ("user_object", "abc123")
    assert called == ["abc123"]  # ensure token extracted and passed to _authenticate_credentials


@pytest.mark.parametrize(
    "query_params, expected_values_present",
    [
        ({"tag": "python"}, ["python"]),
        ({"author": "alice"}, ["alice"]),
        ({"tag": "py", "author": "bob"}, ["py", "bob"]),
        ({}, []),
    ],
)
def test_articles_view_filter_queryset_applies_filters(query_params, expected_values_present):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    view = ArticleViewSet()
    view.request = SimpleNamespace(query_params=query_params)

    class DummyQuerySet:
        def __init__(self):
            self.operations = []

        def filter(self, **kwargs):
            # record the kwargs passed and return self for chaining
            self.operations.append(kwargs)
            return self

    qs = DummyQuerySet()

    # Act
    out = view.filter_queryset(qs)

    # Assert: returned object is the same DummyQuerySet and operations contain expected values
    assert isinstance(out, DummyQuerySet)
    found_values = []
    for op in out.operations:
        for v in op.values():
            # convert to string for robust comparison
            found_values.append(str(v))
    for expected in expected_values_present:
        assert any(expected in fv for fv in found_values), f"expected '{expected}' in any filter values, got {found_values}"
    if not expected_values_present:
        assert out.operations == []


def test_add_slug_to_article_if_not_exists_assigns_and_preserves_slug(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Make sure generate_random_string is deterministic for the test
    monkeypatch.setattr(core_utils, "generate_random_string", lambda length=6: "XYZ123", raising=False)

    # Case 1: article without slug should get one
    article_no_slug = SimpleNamespace(title="Hello World", slug=None)
    # Act
    add_slug_to_article_if_not_exists(sender=None, instance=article_no_slug, created=True)
    # Assert
    assert getattr(article_no_slug, "slug", None) is not None
    slug_str = article_no_slug.slug
    assert isinstance(slug_str, str)
    assert "hello-world" in slug_str.lower() or "xyz123" in slug_str.lower()

    # Case 2: article with existing slug should remain unchanged
    article_with_slug = SimpleNamespace(title="Something", slug="existing-slug")
    original = article_with_slug.slug
    add_slug_to_article_if_not_exists(sender=None, instance=article_with_slug, created=True)
    assert article_with_slug.slug == original


@pytest.mark.parametrize(
    "first_name,last_name,expected_full_name_contains",
    [
        ("John", "Doe", "John Doe"),
        ("", "", ""),  # no names provided -> may return empty or username; verify at least it's a string
    ],
)
def test_user_token_and_get_full_name(monkeypatch, first_name, last_name, expected_full_name_contains):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a User instance without saving to DB; this should work as a plain model instantiation
    try:
        user = User(email="u@example.com", username="uname")
    except TypeError:
        # Some Django model __init__ may require different signature; try creating with no args and set attributes
        user = User()
        user.email = "u@example.com"
        user.username = "uname"

    # Set first/last names
    setattr(user, "first_name", first_name)
    setattr(user, "last_name", last_name)

    # Monkeypatch internal token generator to avoid external dependencies
    monkeypatch.setattr(User, "_generate_jwt_token", lambda self: "fixed-token-999", raising=False)

    # Act
    token_value = user.token
    full_name = user.get_full_name()

    # Assert
    assert token_value == "fixed-token-999"
    assert isinstance(full_name, str)
    if expected_full_name_contains:
        assert full_name == expected_full_name_contains
    else:
        # when no names provided, ensure something string-like is returned (could be username or empty string)
        assert len(full_name) >= 0
