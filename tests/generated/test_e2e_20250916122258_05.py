import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from conduit.apps.articles.renderers import ArticleJSONRenderer, CommentJSONRenderer
except ImportError:
    import pytest
    pytest.skip("conduit.apps.articles.renderers or pytest not available", allow_module_level=True)


def test_article_json_renderer_wraps_dict_and_includes_keys():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()
    payload = {"title": "Deterministic Title", "body": "content"}

    # Act
    rendered = renderer.render(payload)

    # Assert
    assert isinstance(rendered, (bytes, str))
    # Normalize to bytes for consistent checks
    if isinstance(rendered, str):
        rendered_bytes = rendered.encode("utf-8")
    else:
        rendered_bytes = rendered
    # Should wrap original payload under an "article" key and include original keys
    assert b'"article"' in rendered_bytes
    assert b'"title"' in rendered_bytes
    assert b'"body"' in rendered_bytes


def test_article_json_renderer_render_none_returns_empty_bytes():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = ArticleJSONRenderer()

    # Act
    rendered = renderer.render(None)

    # Assert
    # DRF JSONRenderer-based custom renderers commonly return empty bytes for None payloads.
    assert isinstance(rendered, (bytes, str))
    if isinstance(rendered, str):
        rendered_bytes = rendered.encode("utf-8")
    else:
        rendered_bytes = rendered
    assert rendered_bytes == b""


@pytest.mark.parametrize(
    "payload, expected_subbytes",
    [
        ({"body": "c1"}, b'"comment"'),          # single comment -> singular wrapper
        ([{"body": "c1"}, {"body": "c2"}], b'"comments"'),  # list of comments -> plural wrapper
    ],
)
def test_comment_json_renderer_wraps_singular_and_list(payload, expected_subbytes):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = CommentJSONRenderer()

    # Act
    rendered = renderer.render(payload)

    # Assert
    assert isinstance(rendered, (bytes, str))
    if isinstance(rendered, str):
        rendered_bytes = rendered.encode("utf-8")
    else:
        rendered_bytes = rendered
    assert expected_subbytes in rendered_bytes


def test_comment_json_renderer_raises_on_non_serializable_object():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = CommentJSONRenderer()
    # Create a non-JSON-serializable payload (object instance)
    class NonSerializable:
        pass

    payload = {"body": NonSerializable()}

    # Act / Assert
    with pytest.raises(TypeError):
        # Attempting to render non-serializable objects should raise a TypeError from json serialization
        renderer.render(payload)
