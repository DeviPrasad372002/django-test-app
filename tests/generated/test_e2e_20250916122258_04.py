import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

import pytest as _pytest
_pytest.skip('generator: banned private imports detected; skipping module', allow_module_level=True)

try:
    import pytest
    from conduit.apps.articles import relations
    from rest_framework import serializers
except ImportError as e:
    import pytest as _pytest
    _pytest.skip(f"skip tests: missing dependency {e}", allow_module_level=True)


@pytest.mark.parametrize(
    "input_tags, expected_names",
    [
        (["python", "django"], ["python", "django"]),  # normal case
        ([], []),  # edge: empty list
    ],
)
def test_tagrelatedfield_to_internal_value_and_to_representation(tmp_path, monkeypatch, input_tags, expected_names):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create a fake Tag model with a simple objects.get_or_create manager
    created = {}

    class FakeObjects:
        def get_or_create(self, name):
            if name in created:
                return created[name], False
            obj = FakeTag(name)
            created[name] = obj
            return obj, True

    class FakeTag:
        objects = FakeObjects()

        def __init__(self, name):
            self.name = name

        def __repr__(self):
            return f"<FakeTag {self.name!r}>"

    # Monkeypatch the Tag used inside the relations module to our fake
    monkeypatch.setattr(relations, "Tag", FakeTag, raising=False)

    # Act: call to_internal_value then to_representation
    field = relations.TagRelatedField()
    internal = field.to_internal_value(input_tags)

    # Assert: internal is a list of FakeTag instances with correct names
    assert isinstance(internal, list)
    assert [getattr(t, "name", None) for t in internal] == expected_names
    for item in internal:
        assert isinstance(item, FakeTag)

    # Act: representation should return list of names when given the internal list
    representation = field.to_representation(internal)

    # Assert: representation matches expected_names and is of correct type
    assert isinstance(representation, list)
    assert representation == expected_names


def test_tagrelatedfield_to_internal_value_invalid_item_types(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: fake Tag model (should not be used because validation fails before)
    class FakeObjects:
        def get_or_create(self, name):
            return FakeTag(name), True

    class FakeTag:
        objects = FakeObjects()

        def __init__(self, name):
            self.name = name

    monkeypatch.setattr(relations, "Tag", FakeTag, raising=False)

    field = relations.TagRelatedField()

    # Act / Assert: when data contains a non-string element, expect a validation error
    invalid_input = ["valid", 123]

    with pytest.raises(serializers.ValidationError):
        field.to_internal_value(invalid_input)
