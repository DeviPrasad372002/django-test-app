import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import json
    import pytest
    from types import SimpleNamespace

    from conduit.apps.articles.renderers import ArticleJSONRenderer, CommentJSONRenderer
    from conduit.apps.articles.serializers import (
        ArticleSerializer,
        CommentSerializer,
        TagSerializer,
    )
    from conduit.apps.articles.views import (
        ArticleViewSet,
        CommentsListCreateAPIView,
        CommentsDestroyAPIView,
        ArticlesFavoriteAPIView,
        TagListAPIView,
        ArticlesFeedAPIView,
    )
except Exception:
    import pytest

    pytest.skip("Required application modules or dependencies are not available", allow_module_level=True)


@pytest.mark.parametrize(
    "renderer_cls,input_data,expected_key,expect_error",
    [
        (ArticleJSONRenderer, {"title": "Hello"}, "article", False),
        (CommentJSONRenderer, {"body": "Nice"}, "comment", False),
        # error cases: pass non-serializable data (set) and expect a TypeError from json encoding
        (ArticleJSONRenderer, {"tags": {1, 2}}, "article", True),
        (CommentJSONRenderer, {"meta": {1, 2}}, "comment", True),
    ],
)
def test_json_renderers_wrap_and_error_paths(renderer_cls, input_data, expected_key, expect_error):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: instantiate renderer
    renderer = renderer_cls()

    # Act / Assert:
    if expect_error:
        with pytest.raises(TypeError):
            # Act: attempt to render non-JSON-serializable content should raise TypeError
            output = renderer.render(input_data)
            # If renderer returns bytes/str unexpectedly, try to decode/parse to trigger JSON errors
            if isinstance(output, (bytes, bytearray)):
                json.loads(output.decode("utf-8"))
            elif isinstance(output, str):
                json.loads(output)
    else:
        # Act: render JSON from serializable input
        output = renderer.render(input_data)

        # Normalize output to dict for assertions
        if isinstance(output, (bytes, bytearray)):
            text = output.decode("utf-8")
        else:
            text = output
        parsed = json.loads(text)

        # Assert: top-level wrapper key exists and contains the original data keys
        assert expected_key in parsed
        assert isinstance(parsed[expected_key], dict)
        for k, v in input_data.items():
            assert k in parsed[expected_key]
            assert parsed[expected_key][k] == v


@pytest.mark.parametrize(
    "serializer_cls",
    [
        ArticleSerializer,
        CommentSerializer,
        TagSerializer,
    ],
)
def test_serializers_define_meta_model_and_fields(serializer_cls):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act: retrieve Meta inner class from serializer
    meta = getattr(serializer_cls, "Meta", None)

    # Assert: Meta exists and defines model and fields
    assert meta is not None
    fields = getattr(meta, "fields", None)
    model = getattr(meta, "model", None)
    assert model is not None
    assert fields is not None
    # fields should be an iterable (tuple/list) and non-empty
    assert hasattr(fields, "__iter__")
    # Concretely assert it's a tuple or list for predictability
    assert isinstance(fields, (list, tuple))
    assert len(fields) > 0


def test_article_serializer_exposes_expected_helper_methods():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: reference the class
    cls = ArticleSerializer

    # Act / Assert: verify commonly used helper methods exist and are callable
    for method_name in ("get_created_at", "get_updated_at", "get_favorited", "get_favorites_count"):
        method = getattr(cls, method_name, None)
        assert method is not None, f"{method_name} should be defined on ArticleSerializer"
        assert callable(method), f"{method_name} should be callable"


@pytest.mark.parametrize(
    "view_cls,expected_methods",
    [
        (ArticleViewSet, ("list", "retrieve", "update", "destroy")),
        (CommentsListCreateAPIView, ("post", "get")),
        (CommentsDestroyAPIView, ("delete",)),
        (ArticlesFavoriteAPIView, ("post", "delete")),
        (TagListAPIView, ("get",)),
        (ArticlesFeedAPIView, ("get",)),
    ],
)
def test_view_classes_expose_expected_actions(view_cls, expected_methods):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange / Act: inspect view class for method attributes
    for name in expected_methods:
        attr = getattr(view_cls, name, None)
        # Assert: the view class exposes the expected method names and they are callable (functions or callables)
        assert attr is not None, f"{view_cls.__name__} should define {name}"
        assert callable(attr), f"{name} on {view_cls.__name__} should be callable"


def test_tag_serializer_to_representation_handles_simple_object():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create a simple object that mimics the Tag model instance
    # Act: try two common attribute names used for Tag model implementations: 'name' and 'tag'
    serializer = TagSerializer()

    # First variant: object with 'name' attribute
    obj_with_name = SimpleNamespace(name="python")
    # Some TagSerializer implementations return the tag string directly,
    # others return a dict. We accept both but assert type consistency.
    rep1 = serializer.to_representation(obj_with_name)
    assert rep1 is not None

    # Second variant: object with 'tag' attribute
    obj_with_tag = SimpleNamespace(tag="django")
    rep2 = serializer.to_representation(obj_with_tag)
    assert rep2 is not None

    # Assert that representations are either str or dict, and not raising exceptions
    assert isinstance(rep1, (str, dict))
    assert isinstance(rep2, (str, dict))
