import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from types import SimpleNamespace
    import string

    import conduit.apps.core.utils as core_utils
    import conduit.apps.authentication.models as auth_models
except ImportError as e:
    import pytest
    pytest.skip(str(e), allow_module_level=True)


@pytest.mark.parametrize("length", [8, 0])
def test_generate_random_string_returns_string_of_requested_length_and_charset(length):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # (length provided by param)
    # Act
    result = core_utils.generate_random_string(length)
    # Assert
    assert isinstance(result, str)
    assert len(result) == length
    # each character should be alphanumeric (conservative check)
    allowed = string.ascii_letters + string.digits
    assert all(ch in allowed for ch in result)


def test_get_short_name_returns_username():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    dummy = SimpleNamespace(username="alice")
    # Act
    result = auth_models.User.get_short_name(dummy)
    # Assert
    assert isinstance(result, str)
    assert result == "alice"


def test__generate_jwt_token_calls_jwt_encode_with_payload_containing_user_id(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    captured = {}
    def fake_encode(payload, key, algorithm='HS256'):
        captured['payload'] = payload
        captured['key'] = key
        captured['algorithm'] = algorithm
        return "FAKE_TOKEN"
    # Replace the jwt module used inside the auth_models with one that has our encode
    monkeypatch.setattr(auth_models, 'jwt', SimpleNamespace(encode=fake_encode))
    user = SimpleNamespace(pk=123)
    # Act
    token = auth_models.User._generate_jwt_token(user)
    # Assert
    assert token == "FAKE_TOKEN"
    assert isinstance(captured.get('payload'), dict)
    # payload should contain either 'id' or 'user_id' corresponding to the user primary key
    payload = captured['payload']
    assert payload.get('id', payload.get('user_id')) == 123
    # algorithm should be present and be a string
    assert isinstance(captured.get('algorithm'), str)


def test__generate_jwt_token_propagates_errors_from_jwt_encode(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    def raising_encode(*args, **kwargs):
        raise RuntimeError("encode failure")
    monkeypatch.setattr(auth_models, 'jwt', SimpleNamespace(encode=raising_encode))
    user = SimpleNamespace(pk=1)
    # Act / Assert
    with pytest.raises(RuntimeError):
        auth_models.User._generate_jwt_token(user)
