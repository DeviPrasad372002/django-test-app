import importlib.util, pytest
if importlib.util.find_spec('django') is None:
    pytest.skip('django not installed; skipping module', allow_module_level=True)

import os, sys, types as _types, pytest as _pytest, warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
warnings.filterwarnings('ignore', category=PendingDeprecationWarning)
_t = os.environ.get('TARGET_ROOT') or 'target'
if _t and os.path.isdir(_t):
    _p = os.path.abspath(os.path.join(_t, os.pardir))
    [sys.path.insert(0, p) for p in (_p,_t) if p not in sys.path]
    _pkg=_types.ModuleType('target'); _pkg.__path__=[_t]; sys.modules.setdefault('target', _pkg)

try:
    import pytest
    from unittest import mock

    from conduit.apps.articles import signals as articles_signals
    from conduit.apps.authentication import models as auth_models
    from conduit.apps.articles import relations as articles_relations
    from conduit.apps.articles import renderers as articles_renderers
    from rest_framework import serializers
except ImportError:
    import pytest
    pytest.skip("needed application modules or third-party libs not available", allow_module_level=True)


def test_add_slug_to_article_if_not_exists_sets_or_skips_slug(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    class FakeArticle:
        def __init__(self, title, slug=None):
            self.title = title
            self.slug = slug

    # ensure the random generator is predictable and detectable inside slug
    monkeypatch.setattr(articles_signals, "generate_random_string", lambda length=6: "XYZ")

    # Act / Assert (parametrized style inside a single test for clarity)
    # Case 1: created=True and slug missing -> should set slug and include generated value
    article1 = FakeArticle(title="My Title", slug=None)
    articles_signals.add_slug_to_article_if_not_exists(sender=None, instance=article1, created=True)
    assert isinstance(article1.slug, str)
    assert "XYZ" in article1.slug

    # Case 2: created=False and slug missing -> typically should not set slug
    article2 = FakeArticle(title="Another Title", slug=None)
    articles_signals.add_slug_to_article_if_not_exists(sender=None, instance=article2, created=False)
    # If implementation only adds slug on creation, slug remains None
    assert article2.slug is None

    # Case 3: slug already exists -> should not override existing slug
    article3 = FakeArticle(title="Third", slug="already-there")
    articles_signals.add_slug_to_article_if_not_exists(sender=None, instance=article3, created=True)
    assert article3.slug == "already-there"


def test__generate_jwt_token_encodes_payload_and_returns_token(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    captured = {}

    def fake_encode(payload, secret, algorithm="HS256"):
        # capture the payload for assertions and return a predictable token
        captured["payload"] = payload
        captured["secret"] = secret
        captured["algorithm"] = algorithm
        return "FAKE.JWT.TOKEN"

    # Patch the jwt.encode used inside the module
    monkeypatch.setattr(auth_models, "jwt", mock.MagicMock(encode=fake_encode))

    class FakeUser:
        def __init__(self, id):
            self.id = id

    user = FakeUser(id=42)

    # Act
    token = auth_models._generate_jwt_token(user)

    # Assert
    assert isinstance(token, str)
    assert token == "FAKE.JWT.TOKEN"
    assert "payload" in captured
    assert captured["payload"].get("id") == 42
    # expiration or other keys may be present; at minimum id must be included
    assert captured["algorithm"] == "HS256"


def test_TagRelatedField_to_internal_and_to_representation(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Create a fake Tag model and manager with get_or_create behavior
    class FakeTag:
        def __init__(self, name):
            self.name = name

        def __str__(self):
            return self.name

    class FakeManager:
        def __init__(self):
            self.calls = []

        def get_or_create(self, name):
            self.calls.append(name)
            return (FakeTag(name), True)

    fake_manager = FakeManager()
    fake_tag_model = mock.MagicMock()
    fake_tag_model.objects = fake_manager

    # Inject fake Tag model into relations module where TagRelatedField will look it up
    monkeypatch.setattr(articles_relations, "Tag", fake_tag_model, raising=False)

    # Instantiate the TagRelatedField (no args assumed)
    field = articles_relations.TagRelatedField()

    # Act: normal case - string -> model instance
    tag_instance = field.to_internal_value("python")

    # Assert: returned object type and manager was used
    assert isinstance(tag_instance, FakeTag)
    assert fake_manager.calls[-1] == "python"

    # Act: representation of the tag -> string
    rep = field.to_representation(tag_instance)

    # Assert: representation is string and matches tag name
    assert isinstance(rep, str)
    assert rep == "python"

    # Edge case: invalid input (empty string) should raise a ValidationError
    with pytest.raises(serializers.ValidationError):
        field.to_internal_value("")


def test_CommentJSONRenderer_render_handles_data_and_none():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    renderer = articles_renderers.CommentJSONRenderer()

    # Act: render valid payload
    data = {"comment": {"body": "hello world", "author": "alice"}}
    rendered = renderer.render(data)

    # Assert: bytes output and contains expected substrings
    assert isinstance(rendered, (bytes, bytearray))
    assert b"hello world" in rendered
    assert b"comment" in rendered

    # Act & Assert: None data should produce empty bytes (common renderer behavior)
    none_rendered = renderer.render(None)
    assert isinstance(none_rendered, (bytes, bytearray))
    # either empty or valid JSON; ensure no exception and type is bytes
    assert len(none_rendered) >= 0
